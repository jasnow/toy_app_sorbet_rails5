# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AbstractController::AssetPaths
  extend ::T::Sig
end

module AbstractController::Caching::ClassMethods
  extend ::T::Sig
end

module AbstractController::Caching::ConfigMethods
  extend ::T::Sig
end

module AbstractController::Caching::Fragments::ClassMethods
  extend ::T::Sig
end

module AbstractController::Caching::Fragments
  extend ::T::Sig
end

module AbstractController::Caching
  extend ::T::Sig
end

module AbstractController::Callbacks::ClassMethods
  extend ::T::Sig
end

module AbstractController::Callbacks
  extend ::T::Sig
end

module AbstractController::Collector
  extend ::T::Sig
end

class AbstractController::DoubleRenderError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module AbstractController::Helpers::ClassMethods
  extend ::T::Sig
end

module AbstractController::Helpers
  extend ::T::Sig
end

module AbstractController::Logger
  extend ::T::Sig
end

module AbstractController::Railties::RoutesHelpers
  extend ::T::Sig
end

module AbstractController::Railties
  extend ::T::Sig
end

module AbstractController::Rendering
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  extend ::T::Sig
end

module AbstractController::Translation
  extend ::T::Sig
end

module AbstractController::UrlFor::ClassMethods
  extend ::T::Sig
end

module AbstractController::UrlFor
  extend ::T::Sig
end

module AbstractController
  extend ::T::Sig
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::Broadcasting::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::Broadcasting
  extend ::T::Sig
end

module ActionCable::Channel::Callbacks::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::Callbacks
  extend ::T::Sig
end

module ActionCable::Channel::Naming::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::Naming
  extend ::T::Sig
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::PeriodicTimers
  extend ::T::Sig
end

module ActionCable::Channel::Streams
  extend ::T::Sig
end

module ActionCable::Channel
  extend ::T::Sig
end

module ActionCable::Connection
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

module ActionCable::Connection::Authorization
  extend ::T::Sig
end

class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  def beat(); end

  def close(); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*args, &block); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def message_buffer(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*args, &block); end

  def receive(websocket_message); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def websocket(); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

module ActionCable::Connection::Identification::ClassMethods
  extend ::T::Sig
end

module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionCable::Connection::InternalChannel
end

module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def buffered_messages(); end

  def connection(); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::MessageBuffer
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::Stream
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::StreamEventLoop
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def connection(); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*args, &block); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def subscriptions(); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::Subscriptions
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TaggedLoggerProxy
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end

  def websocket(); end
end

class ActionCable::Connection::WebSocket
end

module ActionCable::Connection
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActionCable::Helpers::ActionCableHelper
  extend ::T::Sig
end

module ActionCable::Helpers
  extend ::T::Sig
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  def disconnect(); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::RemoteConnections
end

module ActionCable::Server::Broadcasting
  extend ::T::Sig
end

module ActionCable::Server::Connections
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Server::Connections
  extend ::T::Sig
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::T::Sig
end

module ActionCable::Server
  extend ::T::Sig
end

module ActionCable::SubscriptionAdapter
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

class ActionCable::SubscriptionAdapter::Base
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  extend ::T::Sig
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
end

module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionCable::VERSION
  extend ::T::Sig
end

module ActionCable
  extend ::T::Sig
end

class ActionController::API
  MODULES = ::T.let(nil, ::T.untyped)
end

module ActionController::ApiRendering
  extend ::T::Sig
end

class ActionController::Base
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionController::BasicImplicitRender
  extend ::T::Sig
end

module ActionController::Caching
  extend ::T::Sig
end

module ActionController::ConditionalGet::ClassMethods
  extend ::T::Sig
end

module ActionController::ConditionalGet
  extend ::T::Sig
end

module ActionController::ContentSecurityPolicy::ClassMethods
  extend ::T::Sig
end

module ActionController::ContentSecurityPolicy
  extend ::T::Sig
end

module ActionController::Cookies
  extend ::T::Sig
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::T::Sig
end

module ActionController::EtagWithFlash
  extend ::T::Sig
end

module ActionController::EtagWithTemplateDigest
  extend ::T::Sig
end

module ActionController::Flash::ClassMethods
  extend ::T::Sig
end

module ActionController::Flash
  extend ::T::Sig
end

module ActionController::ForceSSL
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL::ClassMethods
  extend ::T::Sig
end

module ActionController::ForceSSL
  extend ::T::Sig
end

module ActionController::FormBuilder::ClassMethods
  extend ::T::Sig
end

module ActionController::FormBuilder
  extend ::T::Sig
end

module ActionController::Head
  extend ::T::Sig
end

module ActionController::Helpers::ClassMethods
  extend ::T::Sig
end

module ActionController::Helpers
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Basic
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Digest
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Token
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Token
  extend ::T::Sig
end

module ActionController::HttpAuthentication
  extend ::T::Sig
end

module ActionController::ImplicitRender
  extend ::T::Sig
end

module ActionController::Instrumentation::ClassMethods
  extend ::T::Sig
end

module ActionController::Instrumentation
  extend ::T::Sig
end

module ActionController::Live::ClassMethods
  extend ::T::Sig
end

class ActionController::Live::SSE
  WHITELISTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::Live
  extend ::T::Sig
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

module ActionController::MimeResponds
  extend ::T::Sig
end

module ActionController::ParameterEncoding::ClassMethods
  extend ::T::Sig
end

module ActionController::ParameterEncoding
  extend ::T::Sig
end

class ActionController::Parameters
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  extend ::T::Sig
end

module ActionController::ParamsWrapper
  extend ::T::Sig
end

module ActionController::Railties::Helpers
  extend ::T::Sig
end

module ActionController::Railties
  extend ::T::Sig
end

module ActionController::Redirecting
  extend ::T::Sig
end

class ActionController::Renderer
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
  RACK_VALUE_TRANSLATION = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers::All
  extend ::T::Sig
end

module ActionController::Renderers::ClassMethods
  extend ::T::Sig
end

module ActionController::Renderers
  extend ::T::Sig
end

module ActionController::Rendering
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering::ClassMethods
  extend ::T::Sig
end

module ActionController::Rendering
  extend ::T::Sig
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection::ClassMethods
  extend ::T::Sig
end

module ActionController::RequestForgeryProtection::ProtectionMethods
  extend ::T::Sig
end

module ActionController::RequestForgeryProtection
  extend ::T::Sig
end

module ActionController::Rescue
  extend ::T::Sig
end

class ActionController::SessionOverflowError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::Streaming
  extend ::T::Sig
end

module ActionController::StrongParameters
  extend ::T::Sig
end

module ActionController::TemplateAssertions
  extend ::T::Sig
end

module ActionController::TestCase::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionController::TestCase::Behavior
  extend ::T::Sig
end

class ActionController::TestRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::Testing::Functional
  extend ::T::Sig
end

module ActionController::Testing
  extend ::T::Sig
end

module ActionController::UrlFor
  extend ::T::Sig
end

module ActionController
  extend ::T::Sig
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions::ResponseAssertions
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::ResponseAssertions
  extend ::T::Sig
end

module ActionDispatch::Assertions::RoutingAssertions
  extend ::T::Sig
end

module ActionDispatch::Assertions
  extend ::T::Sig
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
  extend ::T::Sig
end

class ActionDispatch::Cookies
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SECRET_TOKEN = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Cookies::ChainedCookieJars
  extend ::T::Sig
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Cookies::SerializedCookieJars
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

module ActionDispatch::Cookies::SerializedCookieJars
  extend ::T::Sig
end

class ActionDispatch::DebugExceptions
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Flash::RequestMethods
  extend ::T::Sig
end

module ActionDispatch::Http::Cache::Request
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
  extend ::T::Sig
end

module ActionDispatch::Http::Cache::Response
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
  extend ::T::Sig
end

module ActionDispatch::Http::Cache
  extend ::T::Sig
end

module ActionDispatch::Http::FilterParameters
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
  extend ::T::Sig
end

module ActionDispatch::Http::FilterRedirect
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
  extend ::T::Sig
end

class ActionDispatch::Http::Headers
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::T::Sig
end

class ActionDispatch::Http::ParameterFilter
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters
  extend ::T::Sig
end

module ActionDispatch::Http::URL
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  extend ::T::Sig
end

module ActionDispatch::Http
  extend ::T::Sig
end

module ActionDispatch::Integration::RequestHelpers
  extend ::T::Sig
end

module ActionDispatch::Integration::Runner
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
  extend ::T::Sig
end

class ActionDispatch::Integration::Session
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Integration::RequestHelpers
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration
  extend ::T::Sig
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::T::Sig
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::T::Sig
end

class ActionDispatch::Journey::Format
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  extend ::T::Sig
end

class ActionDispatch::Journey::GTG::Builder
  DUMMY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::GTG
  extend ::T::Sig
end

module ActionDispatch::Journey::NFA::Dot
  extend ::T::Sig
end

module ActionDispatch::Journey::NFA
  extend ::T::Sig
end

class ActionDispatch::Journey::Nodes::Symbol
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Nodes
  extend ::T::Sig
end

class ActionDispatch::Journey::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Path
  extend ::T::Sig
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Route::VerbMatchers
  extend ::T::Sig
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Visitors
  extend ::T::Sig
end

module ActionDispatch::Journey
  extend ::T::Sig
end

class ActionDispatch::RemoteIp
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  include ::ActionDispatch::Flash::RequestMethods
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  extend ::T::Sig
end

module ActionDispatch::Routing::Mapper::Concerns
  extend ::T::Sig
end

class ActionDispatch::Routing::Mapper::Constraints
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::CustomUrls
  extend ::T::Sig
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  extend ::T::Sig
end

class ActionDispatch::Routing::Mapper::Mapping
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Resources
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Resources
  extend ::T::Sig
end

class ActionDispatch::Routing::Mapper::Scope
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
  extend ::T::Sig
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::PolymorphicRoutes
  extend ::T::Sig
end

module ActionDispatch::Routing::Redirection
  extend ::T::Sig
end

class ActionDispatch::Routing::RouteSet
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::T::Sig
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::T::Sig
end

module ActionDispatch::Routing
  extend ::T::Sig
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  extend ::T::Sig
end

class ActionDispatch::Session::MemCacheStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::MemCacheStore
end

module ActionDispatch::Session::SessionObject
  extend ::T::Sig
end

module ActionDispatch::Session::StaleSessionCheck
  extend ::T::Sig
end

module ActionDispatch::Session
  extend ::T::Sig
end

class ActionDispatch::ShowExceptions
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::TestProcess::FixtureFile
  extend ::T::Sig
end

module ActionDispatch::TestProcess
  extend ::T::Sig
end

class ActionDispatch::TestRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestResponse
  def error?(); end

  def initialize(*_); end

  def missing?(); end

  def parsed_body(); end

  def success?(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionDispatch
  extend ::T::Sig
end

class ActionMailer::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

class ActionMailer::Collector
end

class ActionMailer::DeliveryJob
  def perform(mailer, mail_method, delivery_method, *args); end
end

class ActionMailer::DeliveryJob
end

class ActionMailer::InlinePreviewInterceptor
  include ::Base64
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

module ActionMailer::MailHelper
  extend ::T::Sig
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args); end

  def message(); end

  def processed?(); end
end

class ActionMailer::MessageDelivery
end

module ActionMailer::Parameterized
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

module ActionMailer::Parameterized::ClassMethods
  extend ::T::Sig
end

class ActionMailer::Parameterized::DeliveryJob
  def perform(mailer, mail_method, delivery_method, params, *args); end
end

class ActionMailer::Parameterized::DeliveryJob
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::Mailer
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args); end
end

class ActionMailer::Parameterized::MessageDelivery
end

module ActionMailer::Parameterized
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end
end

module ActionMailer::Previews::ClassMethods
  extend ::T::Sig
end

module ActionMailer::Previews
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionMailer::TestCase::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionMailer::TestCase::Behavior
  extend ::T::Sig
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::T::Sig
end

module ActionMailer::TestHelper
  extend ::T::Sig
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
  extend ::T::Sig
end

module ActionMailer
  extend ::T::Sig
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
  extend ::T::Sig
end

module ActionPack
  extend ::T::Sig
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::ActionViewError
end

class ActionView::ActionViewError
end

class ActionView::Base
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ERB::Util
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Sprockets::Rails::Helper
  include ::Sprockets::Rails::Utils
  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end
end

class ActionView::Base
  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end
end

module ActionView::CollectionCaching
  extend ::T::Sig
end

module ActionView::CompiledTemplates
  extend ::T::Sig
end

module ActionView::Context
  extend ::T::Sig
end

class ActionView::DependencyTracker::ERBTracker
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

module ActionView::Digestor::PerExecutionDigestCacheExpiry
  extend ::T::Sig
end

class ActionView::EncodingError
end

class ActionView::EncodingError
end

module ActionView::Helpers::ActiveModelHelper
  extend ::T::Sig
end

module ActionView::Helpers::AssetTagHelper
  extend ::T::Sig
end

module ActionView::Helpers::AssetUrlHelper
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
  extend ::T::Sig
end

module ActionView::Helpers::AtomFeedHelper
  extend ::T::Sig
end

module ActionView::Helpers::CacheHelper
  extend ::T::Sig
end

module ActionView::Helpers::CaptureHelper
  extend ::T::Sig
end

module ActionView::Helpers::ControllerHelper
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
  extend ::T::Sig
end

module ActionView::Helpers::CspHelper
  extend ::T::Sig
end

module ActionView::Helpers::CsrfHelper
  extend ::T::Sig
end

module ActionView::Helpers::DateHelper
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
  extend ::T::Sig
end

module ActionView::Helpers::DebugHelper
  extend ::T::Sig
end

module ActionView::Helpers::FormHelper
  extend ::T::Sig
end

module ActionView::Helpers::FormOptionsHelper
  extend ::T::Sig
end

module ActionView::Helpers::FormTagHelper
  extend ::T::Sig
end

module ActionView::Helpers::JavaScriptHelper
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
  extend ::T::Sig
end

module ActionView::Helpers::NumberHelper
  extend ::T::Sig
end

module ActionView::Helpers::OutputSafetyHelper
  extend ::T::Sig
end

module ActionView::Helpers::RecordTagHelper
  extend ::T::Sig
end

module ActionView::Helpers::RenderingHelper
  extend ::T::Sig
end

module ActionView::Helpers::SanitizeHelper
  extend ::T::Sig
end

module ActionView::Helpers::TagHelper
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  extend ::T::Sig
end

module ActionView::Helpers::TextHelper
  extend ::T::Sig
end

module ActionView::Helpers::TranslationHelper
  extend ::T::Sig
end

module ActionView::Helpers::UrlHelper
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  extend ::T::Sig
end

module ActionView::Helpers
  extend ::T::Sig
end

module ActionView::Layouts
  extend ::T::Sig
end

class ActionView::LogSubscriber
  def render_collection(event); end

  def render_partial(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
  extend ::T::Sig
end

module ActionView::LookupContext::DetailsCache
  extend ::T::Sig
end

module ActionView::LookupContext::ViewPaths
  extend ::T::Sig
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end

  def path(); end
end

class ActionView::MissingTemplate
end

module ActionView::ModelNaming
  extend ::T::Sig
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*_); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialRenderer
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  extend ::T::Sig
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_template(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  extend ::T::Sig
end

class ActionView::Resolver::Cache
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

module ActionView::RoutingUrlFor
  extend ::T::Sig
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::Template
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Error
  def annoted_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil), output=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Error
end

class ActionView::Template::HTML
  def formats(); end

  def identifier(); end

  def initialize(string, type=T.unsafe(nil)); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::HTML
end

class ActionView::Template::Handlers::ERB
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

module ActionView::Template::Handlers
  extend ::T::Sig
end

class ActionView::Template::Text
  def formats(); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

class ActionView::Template::Types::Type
  SET = ::T.let(nil, ::T.untyped)
end

ActionView::TemplateError = ActionView::Template::Error

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::Rails::Controller::Testing::TemplateAssertions
  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*args, &block); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*_); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
  extend ::T::Sig
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionView::TestCase::TestController
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
  extend ::T::Sig
end

module ActionView::ViewPaths
  extend ::T::Sig
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

class ActionView::WrongEncodingError
end

module ActionView
  extend ::T::Sig
end

module ActiveJob::Arguments
  TYPE_WHITELIST = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  extend ::T::Sig
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Callbacks
  extend ::T::Sig
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  extend ::T::Sig
end

module ActiveJob::Enqueuing
  extend ::T::Sig
end

module ActiveJob::Exceptions
  extend ::T::Sig
end

module ActiveJob::Execution
  extend ::T::Sig
end

module ActiveJob::Logging
  extend ::T::Sig
end

module ActiveJob::QueueAdapter
  extend ::T::Sig
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  extend ::T::Sig
end

module ActiveJob::QueueName
  extend ::T::Sig
end

module ActiveJob::QueuePriority
  extend ::T::Sig
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper::TestQueueAdapter
  extend ::T::Sig
end

module ActiveJob::TestHelper
  extend ::T::Sig
end

module ActiveJob::Translation
  extend ::T::Sig
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::VERSION
  extend ::T::Sig
end

module ActiveJob
  extend ::T::Sig
end

module ActiveModel::AttributeAssignment
  extend ::T::Sig
end

module ActiveModel::AttributeMethods
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods::AttrNames
end

module ActiveModel::AttributeMethods::AttrNames
  extend ::T::Sig
  def self.set_name_cache(name, value); end
end

module ActiveModel::AttributeMethods::ClassMethods
  extend ::T::Sig
end

module ActiveModel::AttributeMethods
  extend ::T::Sig
end

class ActiveModel::AttributeMutationTracker
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Attributes
  def attributes(); end

  def initialize(*_); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, type=T.unsafe(nil), **options); end
end

module ActiveModel::Attributes::ClassMethods
  extend ::T::Sig
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveModel::Callbacks
  extend ::T::Sig
end

module ActiveModel::Conversion::ClassMethods
  extend ::T::Sig
end

module ActiveModel::Conversion
  extend ::T::Sig
end

class ActiveModel::Errors
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveModel::ForbiddenAttributesProtection
  extend ::T::Sig
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
  extend ::T::Sig
end

module ActiveModel::Lint
  extend ::T::Sig
end

module ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::Model
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveModel::Naming
  extend ::T::Sig
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

module ActiveModel::SecurePassword::ClassMethods
  extend ::T::Sig
end

module ActiveModel::SecurePassword::InstanceMethodsOnActivation
  extend ::T::Sig
end

module ActiveModel::SecurePassword
  extend ::T::Sig
end

module ActiveModel::Serialization
  extend ::T::Sig
end

module ActiveModel::Serializers::JSON
  extend ::T::Sig
end

module ActiveModel::Serializers
  extend ::T::Sig
end

module ActiveModel::Translation
  extend ::T::Sig
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::Mutable
  extend ::T::Sig
end

module ActiveModel::Type::Helpers::Numeric
  extend ::T::Sig
end

module ActiveModel::Type::Helpers::TimeValue
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
  extend ::T::Sig
end

module ActiveModel::Type::Helpers::Timezone
  extend ::T::Sig
end

module ActiveModel::Type::Helpers
  extend ::T::Sig
end

class ActiveModel::Type::Integer
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type
  extend ::T::Sig
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
  extend ::T::Sig
end

module ActiveModel::Validations::Callbacks::ClassMethods
  extend ::T::Sig
end

module ActiveModel::Validations::Callbacks
  extend ::T::Sig
end

module ActiveModel::Validations::ClassMethods
  VALID_OPTIONS_FOR_VALIDATE = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Validations::ClassMethods
  extend ::T::Sig
end

module ActiveModel::Validations::Clusivity
  ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Validations::Clusivity
  extend ::T::Sig
end

module ActiveModel::Validations::HelperMethods
  extend ::T::Sig
end

class ActiveModel::Validations::LengthValidator
  CHECKS = ::T.let(nil, ::T.untyped)
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Validations::NumericalityValidator
  CHECKS = ::T.let(nil, ::T.untyped)
  INTEGER_REGEX = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Validations
  extend ::T::Sig
end

module ActiveModel
  extend ::T::Sig
end

module ActiveRecord::Aggregations::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Aggregations
  extend ::T::Sig
end

class ActiveRecord::Associations::AliasTracker
  def aliased_table_for(table_name, aliased_name, type_caster); end

  def aliases(); end

  def initialize(connection, aliases); end
end

class ActiveRecord::Associations::AliasTracker
  def self.create(connection, initial_table, joins); end

  def self.initial_count_for(connection, name, table_joins); end
end

class ActiveRecord::Associations::Association
  def association_scope(); end

  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def extensions(); end

  def initialize(owner, reflection); end

  def initialize_attributes(record, except_from_scope_attributes=T.unsafe(nil)); end

  def inversed_from(record); end

  def inversed_from_queries(record); end

  def klass(); end

  def load_target(); end

  def loaded!(); end

  def loaded?(); end

  def marshal_dump(); end

  def marshal_load(data); end

  def options(*args, &block); end

  def owner(); end

  def reflection(); end

  def reload(); end

  def remove_inverse_instance(record); end

  def reset(); end

  def reset_scope(); end

  def scope(); end

  def set_inverse_instance(record); end

  def set_inverse_instance_from_queries(record); end

  def stale_target?(); end

  def target(); end

  def target=(target); end

  def target_scope(); end
end

class ActiveRecord::Associations::Association
end

class ActiveRecord::Associations::AssociationScope
  def initialize(value_transformation); end

  def scope(association); end

  def value_transformation(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::AssociationScope::ReflectionProxy
  def aliased_table(); end

  def all_includes(); end

  def initialize(reflection, aliased_table); end
end

class ActiveRecord::Associations::AssociationScope::ReflectionProxy
end

class ActiveRecord::Associations::AssociationScope
  def self.create(&block); end

  def self.get_bind_values(owner, chain); end

  def self.scope(association); end
end

class ActiveRecord::Associations::BelongsToAssociation
  def decrement_counters(); end

  def default(&block); end

  def handle_dependency(); end

  def increment_counters(); end

  def target_changed?(); end

  def updated?(); end
end

class ActiveRecord::Associations::BelongsToAssociation
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
end

class ActiveRecord::Associations::Builder::Association
  VALID_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Builder::CollectionAssociation
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
  def association_name(); end

  def initialize(association_name, lhs_model, options); end

  def lhs_model(); end

  def middle_reflection(join_model); end

  def options(); end

  def through_model(); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver::KnownClass
  def initialize(lhs_class, rhs_class_name); end

  def join_table(); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver::KnownClass
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver::KnownTable
  def join_table(); end

  def join_table=(_); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver::KnownTable
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver
  def self.build(lhs_class, name, options); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
end

class ActiveRecord::Associations::Builder::HasOne
end

class ActiveRecord::Associations::Builder::HasOne
end

module ActiveRecord::Associations::Builder
  extend ::T::Sig
end

module ActiveRecord::Associations::ClassMethods
  extend ::T::Sig
end

class ActiveRecord::Associations::CollectionAssociation
  def add_to_target(record, skip_callbacks=T.unsafe(nil), &block); end

  def build(attributes=T.unsafe(nil), &block); end

  def concat(*records); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def destroy_all(); end

  def empty?(); end

  def find(*args); end

  def find_from_target?(); end

  def ids_reader(); end

  def ids_writer(ids); end

  def include?(record); end

  def null_scope?(); end

  def reader(); end

  def replace(other_array); end

  def size(); end

  def transaction(*args); end

  def writer(records); end
end

class ActiveRecord::Associations::CollectionAssociation
end

module ActiveRecord::Associations::ForeignAssociation
  def foreign_key_present?(); end
end

module ActiveRecord::Associations::ForeignAssociation
  extend ::T::Sig
end

class ActiveRecord::Associations::HasManyAssociation
  include ::ActiveRecord::Associations::ForeignAssociation
  def handle_dependency(); end

  def insert_record(record, validate=T.unsafe(nil), raise=T.unsafe(nil)); end
end

class ActiveRecord::Associations::HasManyAssociation
end

class ActiveRecord::Associations::HasManyThroughAssociation
  include ::ActiveRecord::Associations::ThroughAssociation
  def concat_records(records); end
end

class ActiveRecord::Associations::HasManyThroughAssociation
end

class ActiveRecord::Associations::HasOneAssociation
  include ::ActiveRecord::Associations::ForeignAssociation
  def delete(method=T.unsafe(nil)); end

  def handle_dependency(); end

  def replace(record, save=T.unsafe(nil)); end
end

class ActiveRecord::Associations::HasOneAssociation
end

class ActiveRecord::Associations::HasOneThroughAssociation
  include ::ActiveRecord::Associations::ThroughAssociation
end

class ActiveRecord::Associations::HasOneThroughAssociation
end

class ActiveRecord::Associations::JoinDependency
  def alias_tracker(); end

  def apply_column_aliases(relation); end

  def initialize(base, table, associations); end

  def instantiate(result_set, &block); end

  def join_constraints(joins_to_add, join_type, alias_tracker); end

  def join_root(); end

  def reflections(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
  def column_alias(node, column); end

  def column_aliases(node); end

  def columns(); end

  def initialize(tables); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def alias(); end

  def alias=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def column_aliases(); end

  def columns(); end

  def columns=(_); end

  def node(); end

  def node=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
  def initialize(reflection, children); end

  def join_constraints(foreign_table, foreign_klass, join_type, alias_tracker); end

  def reflection(); end

  def table=(table); end

  def tables(); end

  def tables=(tables); end
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
end

class ActiveRecord::Associations::JoinDependency::JoinBase
  def initialize(base_klass, table, children); end
end

class ActiveRecord::Associations::JoinDependency::JoinBase
end

class ActiveRecord::Associations::JoinDependency::JoinPart
  include ::Enumerable
  def base_klass(); end

  def children(); end

  def column_names(*args, &block); end

  def each(&block); end

  def each_children(&block); end

  def extract_record(row, column_names_with_alias); end

  def initialize(base_klass, children); end

  def instantiate(row, aliases, &block); end

  def match?(other); end

  def primary_key(*args, &block); end

  def table(); end

  def table_name(*args, &block); end
end

class ActiveRecord::Associations::JoinDependency::JoinPart
end

class ActiveRecord::Associations::JoinDependency
  def self.make_tree(associations); end

  def self.walk_tree(associations, hash); end
end

class ActiveRecord::Associations::Preloader
  def preload(records, associations, preload_scope=T.unsafe(nil)); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
  def initialize(klass, owners, reflection, preload_scope); end

  def owners(); end

  def preloaded_records(); end

  def reflection(); end

  def run(preloader); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
end

class ActiveRecord::Associations::Preloader::Association
  def initialize(klass, owners, reflection, preload_scope); end

  def klass(); end

  def model(); end

  def owners(); end

  def preload_scope(); end

  def preloaded_records(); end

  def reflection(); end

  def run(preloader); end
end

class ActiveRecord::Associations::Preloader::Association
end

class ActiveRecord::Associations::Preloader::ThroughAssociation
end

class ActiveRecord::Associations::Preloader::ThroughAssociation
end

class ActiveRecord::Associations::Preloader
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Associations::SingularAssociation
  def build(attributes=T.unsafe(nil), &block); end

  def force_reload_reader(); end

  def reader(); end

  def writer(record); end
end

class ActiveRecord::Associations::SingularAssociation
end

module ActiveRecord::Associations::ThroughAssociation
  def source_reflection(*args, &block); end
end

module ActiveRecord::Associations::ThroughAssociation
  extend ::T::Sig
end

module ActiveRecord::Associations
  extend ::T::Sig
end

module ActiveRecord::AttributeAssignment
  extend ::T::Sig
end

module ActiveRecord::AttributeDecorators::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::AttributeDecorators
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods
  BLACKLISTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::AttrNames
  ATTR_36275616475646f51647 = ::T.let(nil, ::T.untyped)
  ATTR_57074616475646f51647 = ::T.let(nil, ::T.untyped)
  ATTR_6716c65756 = ::T.let(nil, ::T.untyped)
  ATTR_b65697 = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::AttrNames
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::ClassMethods
  COLUMN_NAME_ORDER_WHITELIST = ::T.let(nil, ::T.untyped)
  COLUMN_NAME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  ID_ATTRIBUTE_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Query
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Read::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Read
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Serialization::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  extend ::T::Sig
end

class ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Write::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Write
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods
  extend ::T::Sig
end

module ActiveRecord::Attributes::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Attributes
  extend ::T::Sig
end

module ActiveRecord::AutosaveAssociation::AssociationBuilderExtension
  extend ::T::Sig
end

module ActiveRecord::AutosaveAssociation::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::AutosaveAssociation
  extend ::T::Sig
end

module ActiveRecord::Base::GeneratedAssociationMethods
  extend ::T::Sig
end

module ActiveRecord::Batches
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Batches
  extend ::T::Sig
end

module ActiveRecord::Calculations
  extend ::T::Sig
end

module ActiveRecord::Callbacks
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::T::Sig
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

module ActiveRecord::Coders
  extend ::T::Sig
end

module ActiveRecord::CollectionCacheKey
  extend ::T::Sig
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::QueryCache
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::Quoting
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::SQLite3::Quoting
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::SQLite3::SchemaStatements
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::SQLite3
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COLLATE_REGEX = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::Savepoints
  extend ::T::Sig
end

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

module ActiveRecord::ConnectionAdapters::SchemaStatements
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::StatementPool
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters
  extend ::T::Sig
end

module ActiveRecord::ConnectionHandling
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionHandling
  extend ::T::Sig
end

module ActiveRecord::Core::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Core
  extend ::T::Sig
end

module ActiveRecord::CounterCache::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::CounterCache
  extend ::T::Sig
end

module ActiveRecord::DefineCallbacks::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::DefineCallbacks
  extend ::T::Sig
end

module ActiveRecord::Delegation::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::T::Sig
end

module ActiveRecord::Delegation::DelegateCache
  extend ::T::Sig
end

module ActiveRecord::Delegation
  extend ::T::Sig
end

module ActiveRecord::DynamicMatchers
  extend ::T::Sig
end

module ActiveRecord::Enum
  ENUM_CONFLICT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Enum
  extend ::T::Sig
end

module ActiveRecord::Explain
  extend ::T::Sig
end

class ActiveRecord::ExplainRegistry
  def self.collect?(*args, &block); end
end

class ActiveRecord::ExplainSubscriber
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
  extend ::T::Sig
end

class ActiveRecord::FixtureSet
  MAX_ID = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Inheritance::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Inheritance
  extend ::T::Sig
end

module ActiveRecord::Integration::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Integration
  extend ::T::Sig
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
  extend ::T::Sig
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  extend ::T::Sig
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  extend ::T::Sig
end

module ActiveRecord::LegacyYamlAdapter
  extend ::T::Sig
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  extend ::T::Sig
end

module ActiveRecord::Locking::Pessimistic
  extend ::T::Sig
end

module ActiveRecord::Locking
  extend ::T::Sig
end

class ActiveRecord::LogSubscriber
  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration
  MigrationFilenameRegexp = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  extend ::T::Sig
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def add_belongs_to(*_, **options); end

  def add_reference(*_, **options); end

  def add_timestamps(_, **options); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_, **options); end

  def references(*_, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  extend ::T::Sig
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_reference(table_name, ref_name, **options); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  extend ::T::Sig
end

class ActiveRecord::Migration::Compatibility::V5_0
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def create_table(table_name, options=T.unsafe(nil)); end
end

class ActiveRecord::Migration::Compatibility::V5_1
end

module ActiveRecord::Migration::Compatibility
  extend ::T::Sig
  def self.find(version); end
end

module ActiveRecord::Migration::JoinTable
  extend ::T::Sig
end

class ActiveRecord::Migrator
  MIGRATOR_SALT = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ModelSchema::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::ModelSchema
  extend ::T::Sig
end

module ActiveRecord::NestedAttributes
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes::ClassMethods
  REJECT_ALL_BLANK_PROC = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::NestedAttributes
  extend ::T::Sig
end

module ActiveRecord::NoTouching::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::NoTouching
  extend ::T::Sig
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def to_sql(); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
  extend ::T::Sig
end

module ActiveRecord::Persistence::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Persistence
  extend ::T::Sig
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  extend ::T::Sig
end

module ActiveRecord::QueryCache::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::QueryMethods
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::QueryMethods
  extend ::T::Sig
end

module ActiveRecord::Querying
  extend ::T::Sig
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::T::Sig
end

module ActiveRecord::Railties
  extend ::T::Sig
end

module ActiveRecord::ReadonlyAttributes::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::ReadonlyAttributes
  extend ::T::Sig
end

class ActiveRecord::Reflection::AssociationReflection
  INVALID_AUTOMATIC_INVERSE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_AUTOMATIC_INVERSE_MACROS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Reflection::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Reflection
  extend ::T::Sig
end

class ActiveRecord::Relation
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::Merger
  NORMAL_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::WhereClause
  ARRAY_WITH_EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Sanitization::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Sanitization
  extend ::T::Sig
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  extend ::T::Sig
end

module ActiveRecord::Scoping::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Scoping::Default
  extend ::T::Sig
end

module ActiveRecord::Scoping::Named
  extend ::T::Sig
end

class ActiveRecord::Scoping::ScopeRegistry
  VALID_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Scoping::ScopeRegistry
  def self.value_for(*args, &block); end
end

module ActiveRecord::Scoping
  extend ::T::Sig
end

module ActiveRecord::SecureToken::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::SecureToken
  extend ::T::Sig
end

module ActiveRecord::Serialization
  extend ::T::Sig
end

module ActiveRecord::SpawnMethods
  extend ::T::Sig
end

module ActiveRecord::Store::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Store
  extend ::T::Sig
end

module ActiveRecord::Suppressor::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Suppressor
  extend ::T::Sig
end

class ActiveRecord::SuppressorRegistry
  def self.suppressed(*args, &block); end
end

module ActiveRecord::Tasks::DatabaseTasks
  def charset(*arguments); end

  def charset_current(environment=T.unsafe(nil)); end

  def check_protected_environments!(); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def collation(*arguments); end

  def collation_current(environment=T.unsafe(nil)); end

  def create(*arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil)); end

  def current_config(options=T.unsafe(nil)); end

  def current_config=(current_config); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(*arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def load_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_file(format=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def structure_dump(*arguments); end

  def structure_load(*arguments); end

  def target_version(); end
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks
  extend ::T::Sig
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(obj); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(obj); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Tasks
  extend ::T::Sig
end

module ActiveRecord::TestFixtures
  extend ::T::Sig
end

module ActiveRecord::Timestamp::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Timestamp
  extend ::T::Sig
end

module ActiveRecord::TouchLater
  extend ::T::Sig
end

module ActiveRecord::Transactions
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Transactions
  extend ::T::Sig
end

module ActiveRecord::Translation
  extend ::T::Sig
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

ActiveRecord::Type::Binary = ActiveModel::Type::Binary

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

ActiveRecord::Type::Float = ActiveModel::Type::Float

ActiveRecord::Type::Helpers = ActiveModel::Type::Helpers

ActiveRecord::Type::Integer = ActiveModel::Type::Integer

module ActiveRecord::Type::Internal::Timezone
  extend ::T::Sig
end

module ActiveRecord::Type::Internal
  extend ::T::Sig
end

class ActiveRecord::Type::Serialized
end

ActiveRecord::Type::String = ActiveModel::Type::String

class ActiveRecord::Type::Time::Value
end

module ActiveRecord::Type
  extend ::T::Sig
end

module ActiveRecord::TypeCaster
  extend ::T::Sig
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
  extend ::T::Sig
end

module ActiveRecord::Validations::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Validations
  extend ::T::Sig
end

module ActiveRecord
  extend ::T::Sig
end

module ActiveStorage::Attached::Macros
  extend ::T::Sig
end

module ActiveStorage::Downloading
  extend ::T::Sig
end

class ActiveStorage::Service
  def delete(key); end

  def delete_prefixed(prefix); end

  def download(key); end

  def download_chunk(key, range); end

  def exist?(key); end

  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:); end

  def update_metadata(key, **metadata); end

  def upload(key, io, checksum: T.unsafe(nil), **options); end

  def url(key, expires_in:, disposition:, filename:, content_type:); end

  def url_expires_in(); end

  def url_expires_in=(val); end

  def url_expires_in?(); end

  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service
  extend ::ActiveSupport::Autoload
  def self.build(configurator:, service: T.unsafe(nil), **service_config); end

  def self.configure(service_name, configurations); end

  def self.url_expires_in(); end

  def self.url_expires_in=(val); end

  def self.url_expires_in?(); end
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
  extend ::T::Sig
end

module ActiveStorage
  extend ::T::Sig
end

module ActiveSupport::Autoload
  extend ::T::Sig
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  extend ::T::Sig
end

module ActiveSupport::BigDecimalWithDefaultFormat
  extend ::T::Sig
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::ConnectionPoolLike
  def with(); end
end

module ActiveSupport::Cache::ConnectionPoolLike
  extend ::T::Sig
end

class ActiveSupport::Cache::Entry
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  include ::ActiveSupport::Cache::MemCacheStore::LocalCacheWithRaw
  def initialize(*addresses); end

  def stats(); end
  ESCAPE_KEY_CHARS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::MemCacheStore::LocalCacheWithRaw
end

module ActiveSupport::Cache::MemCacheStore::LocalCacheWithRaw
  extend ::T::Sig
end

class ActiveSupport::Cache::MemCacheStore
  def self.build_mem_cache(*addresses); end
end

class ActiveSupport::Cache::MemoryStore
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
end

class ActiveSupport::Cache::RedisCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  include ::ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
  def initialize(namespace: T.unsafe(nil), compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), expires_in: T.unsafe(nil), race_condition_ttl: T.unsafe(nil), error_handler: T.unsafe(nil), **redis_options); end

  def max_key_bytesize(); end

  def mget_capable?(); end

  def mset_capable?(); end

  def redis(); end

  def redis_options(); end
  DEFAULT_ERROR_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIS_OPTIONS = ::T.let(nil, ::T.untyped)
  MAX_KEY_BYTESIZE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
  extend ::T::Sig
end

class ActiveSupport::Cache::RedisCacheStore
  def self.build_redis(redis: T.unsafe(nil), url: T.unsafe(nil), **redis_options); end
end

module ActiveSupport::Cache::Strategy::LocalCache
  extend ::T::Sig
end

module ActiveSupport::Cache::Strategy
  extend ::T::Sig
end

module ActiveSupport::Cache
  extend ::T::Sig
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks
  extend ::T::Sig
end

module ActiveSupport::CompareWithRange
  extend ::T::Sig
end

module ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveSupport::Concurrency
  extend ::T::Sig
end

module ActiveSupport::Configurable
  extend ::T::Sig
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.attribute(*names); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*args, &block); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*args, &block); end
end

module ActiveSupport::Dependencies
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  extend ::T::Sig
end

module ActiveSupport::Dependencies::Loadable
  extend ::T::Sig
end

module ActiveSupport::Dependencies::ModuleConstMissing
  extend ::T::Sig
end

module ActiveSupport::Dependencies
  extend ::T::Sig
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Behavior
  extend ::T::Sig
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  extend ::T::Sig
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::T::Sig
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  extend ::T::Sig
end

module ActiveSupport::Deprecation::InstanceDelegator
  extend ::T::Sig
end

module ActiveSupport::Deprecation::MethodWrapper
  extend ::T::Sig
end

module ActiveSupport::Deprecation::Reporting
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
  extend ::T::Sig
end

class ActiveSupport::Deprecation
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
end

module ActiveSupport::DescendantsTracker
  extend ::T::Sig
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
end

class ActiveSupport::Duration::ISO8601Serializer
end

module ActiveSupport::EachTimeWithZone
  extend ::T::Sig
end

class ActiveSupport::EncryptedFile
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end

  def filter_out_descendants(dirs); end

  def longest_common_subpath(paths); end

  def normalize_extension(ext); end

  def xpath(path); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
end

class ActiveSupport::EventedFileUpdateChecker
end

class ActiveSupport::ExecutionWrapper
  Null = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  extend ::T::Sig
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

module ActiveSupport::IncludeTimeWithZone
  extend ::T::Sig
end

module ActiveSupport::Inflector
  extend ::T::Sig
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
  extend ::T::Sig
end

module ActiveSupport::JSON
  extend ::T::Sig
end

module ActiveSupport::LazyLoadHooks
  extend ::T::Sig
end

class ActiveSupport::LegacyKeyGenerator
  SECRET_MIN_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::T::Sig
end

module ActiveSupport::MarshalWithAutoloading
  extend ::T::Sig
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
end

module ActiveSupport::MessageEncryptor::NullSerializer
  extend ::T::Sig
end

module ActiveSupport::MessageEncryptor::NullVerifier
  extend ::T::Sig
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
end

module ActiveSupport::Messages::Rotator::Encryptor
  extend ::T::Sig
end

module ActiveSupport::Messages::Rotator::Verifier
  extend ::T::Sig
end

module ActiveSupport::Messages::Rotator
  extend ::T::Sig
end

module ActiveSupport::Messages
  extend ::T::Sig
end

module ActiveSupport::Multibyte::Unicode
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Multibyte::Unicode
  extend ::T::Sig
end

module ActiveSupport::Multibyte
  extend ::T::Sig
end

module ActiveSupport::Notifications::Fanout::Subscribers
  extend ::T::Sig
end

module ActiveSupport::Notifications
  extend ::T::Sig
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(val); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(val); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(val); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::T::Sig
end

module ActiveSupport::NumericWithFormat
  extend ::T::Sig
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedHash
end

module ActiveSupport::PerThreadRegistry
  extend ::T::Sig
end

module ActiveSupport::RangeWithFormat
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::RangeWithFormat
  extend ::T::Sig
end

module ActiveSupport::Rescuable
  extend ::T::Sig
end

class ActiveSupport::SafeBuffer
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::SecurityUtils
  extend ::T::Sig
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

module ActiveSupport::TaggedLogging::Formatter
  extend ::T::Sig
end

module ActiveSupport::TaggedLogging
  extend ::T::Sig
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::SetupAndTeardown
end

module ActiveSupport::Testing::Assertions
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
  extend ::T::Sig
end

module ActiveSupport::Testing::ConstantLookup
  extend ::T::Sig
end

module ActiveSupport::Testing::Declarative
  extend ::T::Sig
end

module ActiveSupport::Testing::Deprecation
  extend ::T::Sig
end

module ActiveSupport::Testing::FileFixtures
  extend ::T::Sig
end

module ActiveSupport::Testing::Isolation::Forking
  extend ::T::Sig
end

module ActiveSupport::Testing::Isolation::Subprocess
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
  extend ::T::Sig
end

module ActiveSupport::Testing::Isolation
  extend ::T::Sig
end

module ActiveSupport::Testing::SetupAndTeardown
  extend ::T::Sig
end

module ActiveSupport::Testing::Stream
  extend ::T::Sig
end

module ActiveSupport::Testing::TaggedLogging
  extend ::T::Sig
end

module ActiveSupport::Testing::TimeHelpers
  extend ::T::Sig
end

module ActiveSupport::Testing
  extend ::T::Sig
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITHOUT_COLON = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITH_COLON = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  extend ::T::Sig
end

module ActiveSupport::Tryable
  extend ::T::Sig
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  extend ::T::Sig
end

class ActiveSupport::XMLConverter
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  extend ::T::Sig
end

module ActiveSupport::XmlMini
  extend ::T::Sig
end

module ActiveSupport::XmlMini_REXML
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  extend ::T::Sig
end

module ActiveSupport
  extend ::T::Sig
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Addrinfo
  extend ::T::Sig
end

class ApplicationController
end

class ApplicationController
end

module ApplicationHelper
  extend ::T::Sig
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  extend ::T::Sig
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
  extend ::T::Sig
end

module Arel::Collectors
  extend ::T::Sig
end

module Arel::Compatibility::Wheres::Value
  extend ::T::Sig
end

module Arel::Compatibility
  extend ::T::Sig
end

module Arel::Crud
  extend ::T::Sig
end

module Arel::Expressions
  extend ::T::Sig
end

module Arel::FactoryMethods
  extend ::T::Sig
end

module Arel::Math
  extend ::T::Sig
end

Arel::Node = Arel::Nodes::Node

module Arel::Nodes
  extend ::T::Sig
end

module Arel::OrderPredications
  extend ::T::Sig
end

module Arel::Predications
  extend ::T::Sig
end

class Arel::SelectManager
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::PostgreSQL
  CUBE = ::T.let(nil, ::T.untyped)
  GROUPING_SET = ::T.let(nil, ::T.untyped)
  ROLLUP = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::ToSql
  AND = ::T.let(nil, ::T.untyped)
  COMMA = ::T.let(nil, ::T.untyped)
  DISTINCT = ::T.let(nil, ::T.untyped)
  GROUP_BY = ::T.let(nil, ::T.untyped)
  ORDER_BY = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  WHERE = ::T.let(nil, ::T.untyped)
  WINDOW = ::T.let(nil, ::T.untyped)
end

module Arel::Visitors
  extend ::T::Sig
end

module Arel::WindowPredications
  extend ::T::Sig
end

module Arel
  extend ::T::Sig
end

class ArgumentError
  extend ::T::Sig
end

class Array
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def abbrev(pattern=T.unsafe(nil)); end

  def append(*_); end

  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def difference(*_); end

  def dig(*_); end

  def filter!(); end

  def flatten!(*_); end

  def pack(*_); end

  def prepend(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end

  def union(*_); end
end

class Array
  extend ::T::Sig
  def self.try_convert(_); end
end

module Base64
  extend ::T::Sig
end

BasicObject::BasicObject = BasicObject

class BasicObject
  extend ::T::Sig
end

class BasicSocket
  extend ::T::Sig
end

class Benchmark::Job
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def initialize(width); end

  def item(label=T.unsafe(nil), &blk); end

  def list(); end

  def report(label=T.unsafe(nil), &blk); end

  def width(); end
end

class Benchmark::Job
  extend ::T::Sig
end

class Benchmark::Report
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end

  def item(label=T.unsafe(nil), *format, &blk); end

  def list(); end

  def report(label=T.unsafe(nil), *format, &blk); end
end

class Benchmark::Report
  extend ::T::Sig
end

class Benchmark::Tms
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class Benchmark::Tms
  extend ::T::Sig
end

module Benchmark
  extend ::T::Sig
end

class BigDecimal
  include ::ActiveSupport::NumericWithFormat
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  extend ::T::Sig
  def self.new(*args, **kwargs); end
end

module BigMath
  extend ::T::Sig
end

Bindex = Skiptrace

class Binding
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def clone(); end

  def irb(); end

  def local_variable_defined?(_); end

  def local_variable_get(_); end

  def local_variable_set(_, _1); end

  def receiver(); end

  def source_location(); end
end

class Binding
  extend ::T::Sig
end

module Bundler::BuildMetadata
  extend ::T::Sig
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils::DryRun
  extend ::T::Sig
end

module Bundler::FileUtils::LowMethods
  extend ::T::Sig
end

module Bundler::FileUtils::NoWrite
  extend ::T::Sig
end

module Bundler::FileUtils::StreamUtils_
  extend ::T::Sig
end

module Bundler::FileUtils::Verbose
  extend ::T::Sig
end

module Bundler::FileUtils
  extend ::T::Sig
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

module Bundler::GemHelpers
  extend ::T::Sig
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

module Bundler::MatchPlatform
  extend ::T::Sig
end

module Bundler::Molinillo::Compatibility
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates
  extend ::T::Sig
end

module Bundler::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::UI
  extend ::T::Sig
end

module Bundler::Molinillo
  extend ::T::Sig
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
  extend ::T::Sig
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  extend ::T::Sig
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  extend ::T::Sig
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  extend ::T::Sig
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

module Bundler::SharedHelpers
  extend ::T::Sig
end

class Bundler::UI::RGProxy
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::UI
  extend ::T::Sig
end

module Bundler::URICredentialsFilter
  extend ::T::Sig
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  extend ::T::Sig
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler::YAMLSerializer
  extend ::T::Sig
end

module Bundler
  extend ::T::Sig
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Byebug::Helpers::BinHelper
  extend ::T::Sig
end

module Byebug::Helpers::EvalHelper
  extend ::T::Sig
end

module Byebug::Helpers::FileHelper
  extend ::T::Sig
end

module Byebug::Helpers::FrameHelper
  extend ::T::Sig
end

module Byebug::Helpers::ParseHelper
  extend ::T::Sig
end

module Byebug::Helpers::PathHelper
  extend ::T::Sig
end

module Byebug::Helpers::ReflectionHelper
  extend ::T::Sig
end

module Byebug::Helpers::StringHelper
  extend ::T::Sig
end

module Byebug::Helpers::ThreadHelper
  extend ::T::Sig
end

module Byebug::Helpers::ToggleHelper
  extend ::T::Sig
end

module Byebug::Helpers::VarHelper
  extend ::T::Sig
end

module Byebug::Helpers
  extend ::T::Sig
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Byebug::Printers
  extend ::T::Sig
end

module Byebug::Remote
  extend ::T::Sig
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Byebug::Subcommands::ClassMethods
  extend ::T::Sig
end

module Byebug::Subcommands
  extend ::T::Sig
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Byebug
  extend ::T::Sig
end

class CGI
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class CGI::Cookie
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class CGI::Cookie
  extend ::T::Sig
end

module CGI::Escape
  extend ::T::Sig
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
  extend ::T::Sig
end

class CGI::InvalidEncoding
  extend ::T::Sig
end

module CGI::QueryExtension
  extend ::T::Sig
end

module CGI::Util
  extend ::T::Sig
end

class CGI
  extend ::T::Sig
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractProcess
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ChildProcess::Unix
  extend ::T::Sig
end

module ChildProcess
  extend ::T::Sig
end

class Class
  def json_creatable?(); end
end

class Class
  extend ::T::Sig
end

class ClosedQueueError
  extend ::T::Sig
end

module Comparable
  extend ::T::Sig
end

class Complex
  extend ::T::Sig
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Concurrent
  AtExit = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

module Concurrent::Async
  extend ::T::Sig
end

module Concurrent::AtomicDirectUpdate
  extend ::T::Sig
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  extend ::T::Sig
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

module Concurrent::Collection
  extend ::T::Sig
end

module Concurrent::Concern::Dereferenceable
  extend ::T::Sig
end

module Concurrent::Concern::Logging
  extend ::T::Sig
end

module Concurrent::Concern::Obligation
  extend ::T::Sig
end

module Concurrent::Concern::Observable
  extend ::T::Sig
end

module Concurrent::Concern
  extend ::T::Sig
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

module Concurrent::ExecutorService
  extend ::T::Sig
end

module Concurrent::ImmutableStruct
  extend ::T::Sig
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::MutableStruct
  extend ::T::Sig
end

module Concurrent::Options
  extend ::T::Sig
end

module Concurrent::Promises::FactoryMethods::Configuration
  extend ::T::Sig
end

module Concurrent::Promises::FactoryMethods
  extend ::T::Sig
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  extend ::T::Sig
end

module Concurrent::Promises::Resolvable
  extend ::T::Sig
end

module Concurrent::Promises
  extend ::T::Sig
end

module Concurrent::ReInclude
  extend ::T::Sig
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

module Concurrent::SerialExecutorService
  extend ::T::Sig
end

module Concurrent::SettableStruct
  extend ::T::Sig
end

module Concurrent::Synchronization::AbstractStruct
  extend ::T::Sig
end

module Concurrent::Synchronization::ConditionSignalling
  extend ::T::Sig
end

module Concurrent::Synchronization::MriAttrVolatile
  extend ::T::Sig
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  extend ::T::Sig
end

module Concurrent::Synchronization::RbxAttrVolatile
  extend ::T::Sig
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  extend ::T::Sig
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  extend ::T::Sig
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Synchronization
  extend ::T::Sig
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  extend ::T::Sig
end

module Concurrent::ThreadSafe
  extend ::T::Sig
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::EngineDetector
  extend ::T::Sig
end

module Concurrent::Utility::NativeExtensionLoader
  extend ::T::Sig
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::T::Sig
end

module Concurrent::Utility
  extend ::T::Sig
end

module Concurrent
  extend ::T::Sig
end

ConditionVariable = Thread::ConditionVariable

class Crass::Parser
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

module Crass
  extend ::T::Sig
end

module Dalli
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dalli::Client
  CACHE_NILS = ::T.let(nil, ::T.untyped)
end

class Dalli::Ring
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Dalli::Server
  CAS_HEADER = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_WEIGHT = ::T.let(nil, ::T.untyped)
  FLAG_COMPRESSED = ::T.let(nil, ::T.untyped)
  FLAG_SERIALIZED = ::T.let(nil, ::T.untyped)
  FORMAT = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  KV_HEADER = ::T.let(nil, ::T.untyped)
  MAX_ACCEPTABLE_EXPIRATION_INTERVAL = ::T.let(nil, ::T.untyped)
  NORMAL_HEADER = ::T.let(nil, ::T.untyped)
  NOT_FOUND = ::T.let(nil, ::T.untyped)
  OPCODES = ::T.let(nil, ::T.untyped)
  OP_FORMAT = ::T.let(nil, ::T.untyped)
  REQUEST = ::T.let(nil, ::T.untyped)
  RESPONSE = ::T.let(nil, ::T.untyped)
  RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

module Dalli::Server::KSocket::InstanceMethods
  extend ::T::Sig
end

module Dalli::Server::KSocket
  extend ::T::Sig
end

module Dalli::Server::TCPSocketOptions
  extend ::T::Sig
end

module Dalli::Threadsafe
  extend ::T::Sig
end

module Dalli
  extend ::T::Sig
end

class Data
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Data
  extend ::T::Sig
end

class Date
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date::Infinity
  extend ::T::Sig
end

class Date
  extend ::T::Sig
end

module DateAndTime::Calculations
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

module DateAndTime::Calculations
  extend ::T::Sig
end

module DateAndTime::Compatibility
  extend ::T::Sig
end

module DateAndTime::Zones
  extend ::T::Sig
end

module DateAndTime
  extend ::T::Sig
end

class DateTime
  extend ::T::Sig
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  extend ::T::Sig
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

module DidYouMean
  extend ::T::Sig
end

class Digest::Base
  extend ::T::Sig
end

class Digest::Class
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Digest::Class
  extend ::T::Sig
end

module Digest::Instance
  extend ::T::Sig
end

class Digest::MD5
  extend ::T::Sig
end

class Digest::SHA1
  extend ::T::Sig
end

class Digest::SHA2
  extend ::T::Sig
end

class Digest::SHA256
  extend ::T::Sig
end

class Digest::SHA384
  extend ::T::Sig
end

class Digest::SHA512
  extend ::T::Sig
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  extend ::T::Sig
end

module Digest
  extend ::T::Sig
end

class Dir
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def children(); end

  def each_child(); end

end

module Dir::Tmpname
  extend ::T::Sig
end

class Dir
  extend ::T::Sig
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class EOFError
  extend ::T::Sig
end

class ERB
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class ERB::Compiler::Buffer
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class ERB::Compiler::Buffer
  extend ::T::Sig
end

class ERB::Compiler::ExplicitScanner
  extend ::T::Sig
end

class ERB::Compiler::PercentLine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class ERB::Compiler::PercentLine
  extend ::T::Sig
end

class ERB::Compiler::Scanner
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class ERB::Compiler::Scanner
  extend ::T::Sig
end

class ERB::Compiler::SimpleScanner
  extend ::T::Sig
end

class ERB::Compiler::TrimScanner
  extend ::T::Sig
end

class ERB::Compiler
  extend ::T::Sig
end

module ERB::DefMethod
  extend ::T::Sig
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  extend ::T::Sig
end

class ERB
  extend ::T::Sig
end

Emitter = Psych::Stream::Emitter

class Encoding
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def _dump(*_); end
end

class Encoding::CompatibilityError
  extend ::T::Sig
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  extend ::T::Sig
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::ConverterNotFoundError
  extend ::T::Sig
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::InvalidByteSequenceError
  extend ::T::Sig
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  extend ::T::Sig
end

class Encoding
  extend ::T::Sig
  def self._load(_); end

  def self.locale_charmap(); end
end

class EncodingError
  extend ::T::Sig
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def filter(); end

  def grep_v(_); end

  def lazy(); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

module Enumerable
  extend ::T::Sig
end

class Enumerator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def +(_); end

  def each_with_index(); end

end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Generator
  extend ::T::Sig
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Enumerator::Lazy
  extend ::T::Sig
end

class Enumerator::Yielder
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Enumerator::Yielder
  extend ::T::Sig
end

class Enumerator
  extend ::T::Sig
end

class Errno::E2BIG
  extend ::T::Sig
end

class Errno::EACCES
  extend ::T::Sig
end

class Errno::EADDRINUSE
  extend ::T::Sig
end

class Errno::EADDRNOTAVAIL
  extend ::T::Sig
end

class Errno::EAFNOSUPPORT
  extend ::T::Sig
end

class Errno::EAGAIN
  extend ::T::Sig
end

class Errno::EALREADY
  extend ::T::Sig
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADF
  extend ::T::Sig
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADMSG
  extend ::T::Sig
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

class Errno::EBUSY
  extend ::T::Sig
end

class Errno::ECANCELED
  extend ::T::Sig
end

Errno::ECAPMODE = Errno::NOERROR

class Errno::ECHILD
  extend ::T::Sig
end

class Errno::ECONNABORTED
  extend ::T::Sig
end

class Errno::ECONNREFUSED
  extend ::T::Sig
end

class Errno::ECONNRESET
  extend ::T::Sig
end

class Errno::EDEADLK
  extend ::T::Sig
end

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDESTADDRREQ
  extend ::T::Sig
end

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

class Errno::EDOM
  extend ::T::Sig
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EDQUOT
  extend ::T::Sig
end

class Errno::EEXIST
  extend ::T::Sig
end

class Errno::EFAULT
  extend ::T::Sig
end

class Errno::EFBIG
  extend ::T::Sig
end

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

class Errno::EHOSTDOWN
  extend ::T::Sig
end

class Errno::EHOSTUNREACH
  extend ::T::Sig
end

class Errno::EIDRM
  extend ::T::Sig
end

class Errno::EILSEQ
  extend ::T::Sig
end

class Errno::EINPROGRESS
  extend ::T::Sig
end

class Errno::EINTR
  extend ::T::Sig
end

class Errno::EINVAL
  extend ::T::Sig
end

class Errno::EIO
  extend ::T::Sig
end

Errno::EIPSEC = Errno::NOERROR

class Errno::EISCONN
  extend ::T::Sig
end

class Errno::EISDIR
  extend ::T::Sig
end

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ELOOP
  extend ::T::Sig
end

class Errno::EMFILE
  extend ::T::Sig
end

class Errno::EMLINK
  extend ::T::Sig
end

class Errno::EMSGSIZE
  extend ::T::Sig
end

class Errno::EMULTIHOP
  extend ::T::Sig
end

class Errno::ENAMETOOLONG
  extend ::T::Sig
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENETDOWN
  extend ::T::Sig
end

class Errno::ENETRESET
  extend ::T::Sig
end

class Errno::ENETUNREACH
  extend ::T::Sig
end

class Errno::ENFILE
  extend ::T::Sig
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOBUFS
  extend ::T::Sig
end

class Errno::ENODATA
  extend ::T::Sig
end

class Errno::ENODEV
  extend ::T::Sig
end

class Errno::ENOENT
  extend ::T::Sig
end

class Errno::ENOEXEC
  extend ::T::Sig
end

class Errno::ENOLCK
  extend ::T::Sig
end

class Errno::ENOLINK
  extend ::T::Sig
end

class Errno::ENOMEM
  extend ::T::Sig
end

class Errno::ENOMSG
  extend ::T::Sig
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

class Errno::ENOPROTOOPT
  extend ::T::Sig
end

class Errno::ENOSPC
  extend ::T::Sig
end

class Errno::ENOSR
  extend ::T::Sig
end

class Errno::ENOSTR
  extend ::T::Sig
end

class Errno::ENOSYS
  extend ::T::Sig
end

class Errno::ENOTBLK
  extend ::T::Sig
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTCONN
  extend ::T::Sig
end

class Errno::ENOTDIR
  extend ::T::Sig
end

class Errno::ENOTEMPTY
  extend ::T::Sig
end

class Errno::ENOTRECOVERABLE
  extend ::T::Sig
end

class Errno::ENOTSOCK
  extend ::T::Sig
end

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::ENOTTY
  extend ::T::Sig
end

class Errno::ENXIO
  extend ::T::Sig
end

class Errno::EOPNOTSUPP
  extend ::T::Sig
end

class Errno::EOVERFLOW
  extend ::T::Sig
end

class Errno::EOWNERDEAD
  extend ::T::Sig
end

class Errno::EPERM
  extend ::T::Sig
end

class Errno::EPFNOSUPPORT
  extend ::T::Sig
end

class Errno::EPIPE
  extend ::T::Sig
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPROTO
  extend ::T::Sig
end

class Errno::EPROTONOSUPPORT
  extend ::T::Sig
end

class Errno::EPROTOTYPE
  extend ::T::Sig
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERANGE
  extend ::T::Sig
end

class Errno::EREMOTE
  extend ::T::Sig
end

class Errno::EROFS
  extend ::T::Sig
end

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Errno::ESHUTDOWN
  extend ::T::Sig
end

class Errno::ESOCKTNOSUPPORT
  extend ::T::Sig
end

class Errno::ESPIPE
  extend ::T::Sig
end

class Errno::ESRCH
  extend ::T::Sig
end

class Errno::ESTALE
  extend ::T::Sig
end

class Errno::ETIME
  extend ::T::Sig
end

class Errno::ETIMEDOUT
  extend ::T::Sig
end

class Errno::ETOOMANYREFS
  extend ::T::Sig
end

class Errno::ETXTBSY
  extend ::T::Sig
end

class Errno::EUSERS
  extend ::T::Sig
end

class Errno::EXDEV
  extend ::T::Sig
end

class Errno::NOERROR
  extend ::T::Sig
end

module Errno
  extend ::T::Sig
end

module Erubi
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Erubi
  extend ::T::Sig
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir(); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

module Etc
  extend ::T::Sig
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

class Exception
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def full_message(*_); end

end

class Exception
  extend ::T::Sig
  def self.exception(*_); end

  def self.to_tty?(); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  extend ::T::Sig
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

module ExecJS
  VERSION = ::T.let(nil, ::T.untyped)
end

module ExecJS::Encoding
  extend ::T::Sig
end

module ExecJS::Runtimes
  Disabled = ::T.let(nil, ::T.untyped)
  Duktape = ::T.let(nil, ::T.untyped)
  JScript = ::T.let(nil, ::T.untyped)
  JavaScriptCore = ::T.let(nil, ::T.untyped)
  MiniRacer = ::T.let(nil, ::T.untyped)
  Node = ::T.let(nil, ::T.untyped)
  RubyRacer = ::T.let(nil, ::T.untyped)
  RubyRhino = ::T.let(nil, ::T.untyped)
  SpiderMonkey = ::T.let(nil, ::T.untyped)
  Spidermonkey = ::T.let(nil, ::T.untyped)
  V8 = ::T.let(nil, ::T.untyped)
end

module ExecJS::Runtimes
  extend ::T::Sig
end

module ExecJS
  extend ::T::Sig
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
end

FFI::CallbackInfo = FFI::FunctionType

module FFI::DataConverter
  extend ::T::Sig
end

class FFI::DynamicLibrary
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

FFI::FunctionInfo = FFI::FunctionType

module FFI::IO
  extend ::T::Sig
end

module FFI::LastError
  extend ::T::Sig
end

module FFI::Library
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

module FFI::Library
  extend ::T::Sig
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
  extend ::T::Sig
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

module FFI::Platform
  extend ::T::Sig
end

class FFI::Pointer
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Struct::InlineArray
  include ::Enumerable
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayoutBuilder
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::Type
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

FFI::Type::Function = FFI::FunctionType

FFI::Type::Struct = FFI::StructByValue

module FFI
  extend ::T::Sig
end

class FalseClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class FalseClass
  extend ::T::Sig
end

module Fcntl
  FD_CLOEXEC = ::T.let(nil, ::T.untyped)
  F_DUPFD = ::T.let(nil, ::T.untyped)
  F_GETFD = ::T.let(nil, ::T.untyped)
  F_GETFL = ::T.let(nil, ::T.untyped)
  F_GETLK = ::T.let(nil, ::T.untyped)
  F_RDLCK = ::T.let(nil, ::T.untyped)
  F_SETFD = ::T.let(nil, ::T.untyped)
  F_SETFL = ::T.let(nil, ::T.untyped)
  F_SETLK = ::T.let(nil, ::T.untyped)
  F_SETLKW = ::T.let(nil, ::T.untyped)
  F_UNLCK = ::T.let(nil, ::T.untyped)
  F_WRLCK = ::T.let(nil, ::T.untyped)
  O_ACCMODE = ::T.let(nil, ::T.untyped)
  O_APPEND = ::T.let(nil, ::T.untyped)
  O_CREAT = ::T.let(nil, ::T.untyped)
  O_EXCL = ::T.let(nil, ::T.untyped)
  O_NDELAY = ::T.let(nil, ::T.untyped)
  O_NOCTTY = ::T.let(nil, ::T.untyped)
  O_NONBLOCK = ::T.let(nil, ::T.untyped)
  O_RDONLY = ::T.let(nil, ::T.untyped)
  O_RDWR = ::T.let(nil, ::T.untyped)
  O_TRUNC = ::T.let(nil, ::T.untyped)
  O_WRONLY = ::T.let(nil, ::T.untyped)
end

module Fcntl
  extend ::T::Sig
end

class Fiber
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  extend ::T::Sig
  def self.current(); end

  def self.yield(*_); end
end

class FiberError
  extend ::T::Sig
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

module File::Constants
  extend ::T::Sig
end

class File::Stat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def size?(); end
end

class File::Stat
  extend ::T::Sig
end

class File
  extend ::T::Sig
  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.probe_stat_in(dir); end

end

module FileTest
  extend ::T::Sig
  def self.blockdev?(_); end

  def self.chardev?(_); end

  def self.directory?(_); end

  def self.empty?(_); end

  def self.executable?(_); end

  def self.executable_real?(_); end

  def self.exist?(_); end

  def self.exists?(_); end

  def self.file?(_); end

  def self.grpowned?(_); end

  def self.identical?(_, _1); end

  def self.owned?(_); end

  def self.pipe?(_); end

  def self.readable?(_); end

  def self.readable_real?(_); end

  def self.setgid?(_); end

  def self.setuid?(_); end

  def self.size(_); end

  def self.size?(_); end

  def self.socket?(_); end

  def self.sticky?(_); end

  def self.symlink?(_); end

  def self.world_readable?(_); end

  def self.world_writable?(_); end

  def self.writable?(_); end

  def self.writable_real?(_); end

  def self.zero?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  extend ::T::Sig
  extend ::FileUtils::DryRun
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

class FileUtils::Entry_
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def blockdev?(); end

  def chardev?(); end

  def chmod(mode); end

  def chown(uid, gid); end

  def copy(dest); end

  def copy_file(dest); end

  def copy_metadata(path); end

  def dereference?(); end

  def directory?(); end

  def door?(); end

  def entries(); end

  def exist?(); end

  def file?(); end

  def initialize(a, b=T.unsafe(nil), deref=T.unsafe(nil)); end

  def link(dest); end

  def lstat(); end

  def lstat!(); end

  def path(); end

  def pipe?(); end

  def platform_support(); end

  def postorder_traverse(); end

  def prefix(); end

  def preorder_traverse(); end

  def rel(); end

  def remove(); end

  def remove_dir1(); end

  def remove_file(); end

  def socket?(); end

  def stat(); end

  def stat!(); end

  def symlink?(); end

  def traverse(); end

  def wrap_traverse(pre, post); end
end

class FileUtils::Entry_
  extend ::T::Sig
end

module FileUtils::LowMethods
  extend ::T::Sig
end

module FileUtils::NoWrite
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::NoWrite
  extend ::T::Sig
  extend ::FileUtils::NoWrite
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils::StreamUtils_
  extend ::T::Sig
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::T::Sig
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::T::Sig
  extend ::FileUtils::StreamUtils_
  def self.cd(dir, verbose: T.unsafe(nil), &block); end

  def self.chdir(dir, verbose: T.unsafe(nil), &block); end

  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.cmp(a, b); end

  def self.collect_method(opt); end

  def self.commands(); end

  def self.compare_file(a, b); end

  def self.compare_stream(a, b); end

  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.copy_entry(src, dest, preserve=T.unsafe(nil), dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.copy_file(src, dest, preserve=T.unsafe(nil), dereference=T.unsafe(nil)); end

  def self.copy_stream(src, dest); end

  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.getwd(); end

  def self.have_option?(mid, opt); end

  def self.identical?(a, b); end

  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.options(); end

  def self.options_of(mid); end

  def self.private_module_function(name); end

  def self.pwd(); end

  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.remove_dir(path, force=T.unsafe(nil)); end

  def self.remove_entry(path, force=T.unsafe(nil)); end

  def self.remove_entry_secure(path, force=T.unsafe(nil)); end

  def self.remove_file(path, force=T.unsafe(nil)); end

  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.uptodate?(new, old_list); end
end

module Find
end

module Find
  extend ::T::Sig
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::ActiveSupport::NumericWithFormat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  def to_d(precision=T.unsafe(nil)); end
end

class Float
  extend ::T::Sig
end

class FloatDomainError
  extend ::T::Sig
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  extend ::T::Sig
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
end

class FrozenError
end

module GC
  def garbage_collect(*_); end
end

module GC::Profiler
  extend ::T::Sig
end

module GC
  extend ::T::Sig
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::AvailableSet
  include ::Enumerable
  def <<(o); end

  def add(spec, source); end

  def all_specs(); end

  def each(&blk); end

  def each_spec(); end

  def empty?(); end

  def find_all(req); end

  def inject_into_list(dep_list); end

  def match_platform!(); end

  def pick_best!(); end

  def prefetch(reqs); end

  def remote(); end

  def remote=(remote); end

  def remove_installed!(dep); end

  def set(); end

  def size(); end

  def sorted(); end

  def source_for(spec); end

  def to_request_set(development=T.unsafe(nil)); end
end

class Gem::AvailableSet::Tuple
  def source(); end

  def source=(_); end

  def spec(); end

  def spec=(_); end
end

class Gem::AvailableSet::Tuple
  def self.[](*_); end

  def self.members(); end
end

class Gem::AvailableSet
end

class Gem::BasicSpecification
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def activated?(); end

  def base_dir(); end

  def base_dir=(base_dir); end

  def contains_requirable_file?(file); end

  def datadir(); end

  def default_gem?(); end

  def extension_dir(); end

  def extension_dir=(extension_dir); end

  def extensions_dir(); end

  def full_gem_path(); end

  def full_gem_path=(full_gem_path); end

  def full_name(); end

  def full_require_paths(); end

  def gem_build_complete_path(); end

  def gem_dir(); end

  def gems_dir(); end

  def ignored=(ignored); end

  def internal_init(); end

  def lib_dirs_glob(); end

  def loaded_from(); end

  def loaded_from=(loaded_from); end

  def matches_for_glob(glob); end

  def name(); end

  def platform(); end

  def raw_require_paths(); end

  def require_paths(); end

  def source_paths(); end

  def stubbed?(); end

  def this(); end

  def to_fullpath(path); end

  def to_spec(); end

  def version(); end
end

class Gem::BasicSpecification
  extend ::T::Sig
  def self.default_specifications_dir(); end
end

module Gem::BundlerVersionFinder
end

module Gem::BundlerVersionFinder
  extend ::T::Sig
  def self.bundler_version(); end

  def self.bundler_version_with_reason(); end

  def self.compatible?(spec); end

  def self.filter!(specs); end

  def self.missing_version_message(); end
end

class Gem::Command
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def add_extra_args(args); end

  def add_option(*opts, &handler); end

  def arguments(); end

  def begins?(long, short); end

  def command(); end

  def defaults(); end

  def defaults=(defaults); end

  def defaults_str(); end

  def description(); end

  def execute(); end

  def get_all_gem_names(); end

  def get_all_gem_names_and_versions(); end

  def get_one_gem_name(); end

  def get_one_optional_argument(); end

  def handle_options(args); end

  def handles?(args); end

  def initialize(command, summary=T.unsafe(nil), defaults=T.unsafe(nil)); end

  def invoke(*args); end

  def invoke_with_build_args(args, build_args); end

  def merge_options(new_options); end

  def options(); end

  def program_name(); end

  def program_name=(program_name); end

  def remove_option(name); end

  def show_help(); end

  def show_lookup_failure(gem_name, version, errors, domain, required_by=T.unsafe(nil)); end

  def summary(); end

  def summary=(summary); end

  def usage(); end

  def when_invoked(&block); end
  HELP = ::T.let(nil, ::T.untyped)
end

class Gem::Command
  def self.add_common_option(*args, &handler); end

  def self.add_specific_extra_args(cmd, args); end

  def self.build_args(); end

  def self.build_args=(value); end

  def self.common_options(); end

  def self.extra_args(); end

  def self.extra_args=(value); end

  def self.specific_extra_args(cmd); end

  def self.specific_extra_args_hash(); end
end

class Gem::CommandLineError
  extend ::T::Sig
end

module Gem::Commands
end

module Gem::Commands
  extend ::T::Sig
end

class Gem::ConfigFile
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def api_keys(); end

  def args(); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def bulk_threshold(); end

  def bulk_threshold=(bulk_threshold); end

  def cert_expiration_length_days(); end

  def cert_expiration_length_days=(cert_expiration_length_days); end

  def check_credentials_permissions(); end

  def concurrent_downloads(); end

  def concurrent_downloads=(concurrent_downloads); end

  def config_file_name(); end

  def credentials_path(); end

  def disable_default_gem_server(); end

  def disable_default_gem_server=(disable_default_gem_server); end

  def each(&block); end

  def handle_arguments(arg_list); end

  def home(); end

  def home=(home); end

  def initialize(args); end

  def load_api_keys(); end

  def load_file(filename); end

  def path(); end

  def path=(path); end

  def really_verbose(); end

  def rubygems_api_key(); end

  def rubygems_api_key=(api_key); end

  def set_api_key(host, api_key); end

  def sources(); end

  def sources=(sources); end

  def ssl_ca_cert(); end

  def ssl_ca_cert=(ssl_ca_cert); end

  def ssl_client_cert(); end

  def ssl_verify_mode(); end

  def to_yaml(); end

  def unset_api_key!(); end

  def update_sources(); end

  def update_sources=(update_sources); end

  def verbose(); end

  def verbose=(verbose); end

  def write(); end
  DEFAULT_BACKTRACE = ::T.let(nil, ::T.untyped)
  DEFAULT_BULK_THRESHOLD = ::T.let(nil, ::T.untyped)
  DEFAULT_CERT_EXPIRATION_LENGTH_DAYS = ::T.let(nil, ::T.untyped)
  DEFAULT_CONCURRENT_DOWNLOADS = ::T.let(nil, ::T.untyped)
  DEFAULT_UPDATE_SOURCES = ::T.let(nil, ::T.untyped)
  DEFAULT_VERBOSITY = ::T.let(nil, ::T.untyped)
  OPERATING_SYSTEM_DEFAULTS = ::T.let(nil, ::T.untyped)
  PLATFORM_DEFAULTS = ::T.let(nil, ::T.untyped)
  SYSTEM_CONFIG_PATH = ::T.let(nil, ::T.untyped)
  SYSTEM_WIDE_CONFIG_FILE = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
end

class Gem::ConflictError
  def conflicts(); end

  def initialize(target, conflicts); end

  def target(); end
end

class Gem::ConflictError
  extend ::T::Sig
end

class Gem::ConsoleUI
  def initialize(); end
end

class Gem::ConsoleUI
end

module Gem::DefaultUserInteraction
  include ::Gem::Text
  def ui(); end

  def ui=(new_ui); end

  def use_ui(new_ui, &block); end
end

module Gem::DefaultUserInteraction
  extend ::T::Sig
  def self.ui(); end

  def self.ui=(new_ui); end

  def self.use_ui(new_ui); end
end

class Gem::Dependency
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def all_sources(); end

  def all_sources=(all_sources); end

  def encode_with(coder); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def initialize(name, *requirements); end

  def latest_version?(); end

  def match?(obj, version=T.unsafe(nil), allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def matching_specs(platform_only=T.unsafe(nil)); end

  def merge(other); end

  def name(); end

  def name=(name); end

  def prerelease=(prerelease); end

  def prerelease?(); end

  def requirement(); end

  def requirements_list(); end

  def runtime?(); end

  def source(); end

  def source=(source); end

  def specific?(); end

  def to_lock(); end

  def to_spec(); end

  def to_specs(); end

  def to_yaml_properties(); end

  def type(); end
end

class Gem::Dependency
  extend ::T::Sig
end

class Gem::DependencyError
  extend ::T::Sig
end

class Gem::DependencyInstaller
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def _deprecated_add_found_dependencies(to_do, dependency_list); end

  def _deprecated_gather_dependencies(); end

  def add_found_dependencies(*args, &block); end

  def available_set_for(dep_or_name, version); end

  def consider_local?(); end

  def consider_remote?(); end

  def document(); end

  def errors(); end

  def find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def gather_dependencies(*args, &block); end

  def in_background(what); end

  def initialize(options=T.unsafe(nil)); end

  def install(dep_or_name, version=T.unsafe(nil)); end

  def install_development_deps(); end

  def installed_gems(); end

  def resolve_dependencies(dep_or_name, version); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
  extend ::Gem::Deprecate
end

class Gem::DependencyList
  include ::Enumerable
  include ::TSort
  def add(*gemspecs); end

  def clear(); end

  def dependency_order(); end

  def development(); end

  def development=(development); end

  def each(&block); end

  def find_name(full_name); end

  def initialize(development=T.unsafe(nil)); end

  def ok?(); end

  def ok_to_remove?(full_name, check_dev=T.unsafe(nil)); end

  def remove_by_name(full_name); end

  def remove_specs_unsatisfied_by(dependencies); end

  def spec_predecessors(); end

  def specs(); end

  def tsort_each_node(&block); end

  def why_not_ok?(quick=T.unsafe(nil)); end
end

class Gem::DependencyList
  def self.from_specs(); end
end

class Gem::DependencyRemovalException
  extend ::T::Sig
end

class Gem::DependencyResolutionError
  def conflict(); end

  def conflicting_dependencies(); end

  def initialize(conflict); end
end

class Gem::DependencyResolutionError
  extend ::T::Sig
end

module Gem::Deprecate
  extend ::T::Sig
  def self.deprecate(name, repl, year, month); end

  def self.skip(); end

  def self.skip=(v); end

  def self.skip_during(); end
end

class Gem::DocumentError
  extend ::T::Sig
end

class Gem::EndOfYAMLException
  extend ::T::Sig
end

class Gem::ErrorReason
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Gem::ErrorReason
  extend ::T::Sig
end

class Gem::Exception
  def _deprecated_source_exception(); end

  def source_exception(*args, &block); end

  def source_exception=(source_exception); end
end

class Gem::Exception
  extend ::T::Sig
  extend ::Gem::Deprecate
end

module Gem::Ext
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def build_args(); end

  def build_args=(build_args); end

  def build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def build_extension(extension, dest_path); end

  def build_extensions(); end

  def builder_for(extension); end

  def initialize(spec, build_args=T.unsafe(nil)); end

  def write_gem_make_out(output); end
  CHDIR_MONITOR = ::T.let(nil, ::T.untyped)
  CHDIR_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Ext::Builder
  def self.class_name(); end

  def self.make(dest_path, results); end

  def self.redirector(); end

  def self.run(command, results, command_name=T.unsafe(nil)); end
end

class Gem::Ext::CmakeBuilder
end

class Gem::Ext::CmakeBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ConfigureBuilder
end

class Gem::Ext::ConfigureBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Ext::RakeBuilder
end

class Gem::Ext::RakeBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

module Gem::Ext
  extend ::T::Sig
end

class Gem::FilePermissionError
  def directory(); end

  def initialize(directory); end
end

class Gem::FilePermissionError
  extend ::T::Sig
end

class Gem::FormatException
  def file_path(); end

  def file_path=(file_path); end
end

class Gem::FormatException
  extend ::T::Sig
end

class Gem::GemNotFoundException
  extend ::T::Sig
end

class Gem::GemNotInHomeException
  def spec(); end

  def spec=(spec); end
end

class Gem::GemNotInHomeException
  extend ::T::Sig
end

class Gem::ImpossibleDependenciesError
  def build_message(); end

  def conflicts(); end

  def dependency(); end

  def initialize(request, conflicts); end

  def request(); end
end

class Gem::ImpossibleDependenciesError
  extend ::T::Sig
end

class Gem::InstallError
  extend ::T::Sig
end

class Gem::Installer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def _deprecated_extension_build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def app_script_text(bin_file_name); end

  def bin_dir(); end

  def build_extensions(); end

  def build_root(); end

  def check_executable_overwrite(filename); end

  def check_that_user_bin_dir_is_in_path(); end

  def default_spec_file(); end

  def dir(); end

  def ensure_dependencies_met(); end

  def ensure_dependency(spec, dependency); end

  def ensure_loadable_spec(); end

  def ensure_required_ruby_version_met(); end

  def ensure_required_rubygems_version_met(); end

  def extension_build_error(*args, &block); end

  def extract_bin(); end

  def extract_files(); end

  def formatted_program_filename(filename); end

  def gem(); end

  def gem_dir(); end

  def gem_home(); end

  def generate_bin(); end

  def generate_bin_script(filename, bindir); end

  def generate_bin_symlink(filename, bindir); end

  def generate_windows_script(filename, bindir); end

  def initialize(package, options=T.unsafe(nil)); end

  def install(); end

  def installation_satisfies_dependency?(dependency); end

  def installed_specs(); end

  def options(); end

  def pre_install_checks(); end

  def process_options(); end

  def run_post_build_hooks(); end

  def run_post_install_hooks(); end

  def run_pre_install_hooks(); end

  def shebang(bin_file_name); end

  def spec(); end

  def spec_file(); end

  def unpack(directory); end

  def verify_gem_home(unpack=T.unsafe(nil)); end

  def verify_spec(); end

  def windows_stub_script(bindir, bin_file_name); end

  def write_build_info_file(); end

  def write_cache_file(); end

  def write_default_spec(); end

  def write_spec(); end
  ENV_PATHS = ::T.let(nil, ::T.untyped)
end

class Gem::Installer
  extend ::Gem::Deprecate
  def self.at(path, options=T.unsafe(nil)); end

  def self.exec_format(); end

  def self.exec_format=(exec_format); end

  def self.for_spec(spec, options=T.unsafe(nil)); end

  def self.install_lock(); end

  def self.path_warning(); end

  def self.path_warning=(path_warning); end
end

class Gem::InvalidSpecificationException
  extend ::T::Sig
end

class Gem::Licenses
  EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  NONSTANDARD = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  extend ::Gem::Text
  def self.match?(license); end

  def self.suggestions(license); end
end

class Gem::List
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(&blk); end

  def initialize(value=T.unsafe(nil), tail=T.unsafe(nil)); end

  def prepend(value); end

  def tail(); end

  def tail=(tail); end

  def to_a(); end

  def value(); end

  def value=(value); end
end

class Gem::List
  extend ::T::Sig
  def self.prepend(list, value); end
end

class Gem::LoadError
  def name(); end

  def name=(name); end

  def requirement(); end

  def requirement=(requirement); end
end

class Gem::LoadError
  extend ::T::Sig
end

class Gem::MissingSpecError
  def initialize(name, requirement); end
end

class Gem::MissingSpecError
  extend ::T::Sig
end

class Gem::MissingSpecVersionError
  def initialize(name, requirement, specs); end

  def specs(); end
end

class Gem::MissingSpecVersionError
  extend ::T::Sig
end

class Gem::NameTuple
  include ::Comparable
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, version, platform=T.unsafe(nil)); end

  def match_platform?(); end

  def name(); end

  def platform(); end

  def prerelease?(); end

  def spec_name(); end

  def to_a(); end

  def version(); end
end

class Gem::NameTuple
  def self.from_list(list); end

  def self.null(); end

  def self.to_basic(list); end
end

class Gem::OperationNotSupportedError
  extend ::T::Sig
end

class Gem::Package
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def add_checksums(tar); end

  def add_contents(tar); end

  def add_files(tar); end

  def add_metadata(tar); end

  def build(skip_validation=T.unsafe(nil), strict_validation=T.unsafe(nil)); end

  def build_time(); end

  def build_time=(build_time); end

  def checksums(); end

  def contents(); end

  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def digest(entry); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def extract_tar_gz(io, destination_dir, pattern=T.unsafe(nil)); end

  def file_mode(mode); end

  def files(); end

  def gzip_to(io); end

  def initialize(gem, security_policy); end

  def install_location(filename, destination_dir); end

  def load_spec(entry); end

  def mkdir_p_safe(mkdir, mkdir_options, destination_dir, file_name); end

  def normalize_path(pathname); end

  def open_tar_gz(io); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def read_checksums(gem); end

  def security_policy(); end

  def security_policy=(security_policy); end

  def setup_signer(signer_options: T.unsafe(nil)); end

  def spec(); end

  def spec=(spec); end

  def verify(); end

  def verify_checksums(digests, checksums); end

  def verify_entry(entry); end

  def verify_files(gem); end

  def verify_gz(entry); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::Error
end

class Gem::Package::Error
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::FormatError
  def initialize(message, source=T.unsafe(nil)); end

  def path(); end
end

class Gem::Package::FormatError
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::PathError
  def initialize(destination, destination_dir); end
end

class Gem::Package::PathError
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.strict_oct(str); end
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarReader
  include ::Enumerable
  def close(); end

  def each(&blk); end

  def each_entry(); end

  def initialize(io); end

  def rewind(); end

  def seek(name); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def add_file(name, mode); end

  def add_file_digest(name, mode, digest_algorithms); end

  def add_file_signed(name, mode, signer); end

  def add_file_simple(name, mode, size); end

  def add_symlink(name, target, mode); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def flush(); end

  def initialize(io); end

  def mkdir(name, mode); end

  def split_name(name); end
end

class Gem::Package::TarWriter::BoundedStream
  def initialize(io, limit); end

  def limit(); end

  def write(data); end

  def written(); end
end

class Gem::Package::TarWriter::BoundedStream
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::RestrictedStream
  def initialize(io); end

  def write(data); end
end

class Gem::Package::TarWriter::RestrictedStream
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package::TooLongFileName
end

class Gem::Package::TooLongFileName
end

class Gem::Package
  def self.build(spec, skip_validation=T.unsafe(nil), strict_validation=T.unsafe(nil), file_name=T.unsafe(nil)); end

  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::PathSupport
  extend ::T::Sig
end

class Gem::Platform
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def cpu(); end

  def cpu=(cpu); end

  def eql?(other); end

  def initialize(arch); end

  def os(); end

  def os=(os); end

  def to_a(); end

  def version(); end

  def version=(version); end
  JAVA = ::T.let(nil, ::T.untyped)
  MINGW = ::T.let(nil, ::T.untyped)
  MSWIN = ::T.let(nil, ::T.untyped)
  MSWIN64 = ::T.let(nil, ::T.untyped)
  X64_MINGW = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  extend ::T::Sig
  def self.installable?(spec); end

  def self.local(); end

  def self.match(platform); end

  def self.new(arch); end
end

class Gem::PlatformMismatch
  def add_platform(platform); end

  def initialize(name, version); end

  def name(); end

  def platforms(); end

  def version(); end

  def wordy(); end
end

class Gem::PlatformMismatch
  extend ::T::Sig
end

class Gem::RemoteError
  extend ::T::Sig
end

class Gem::RemoteFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cache_update_path(uri, path=T.unsafe(nil), update=T.unsafe(nil)); end

  def close_all(); end

  def correct_for_windows_path(path); end

  def download(spec, source_uri, install_dir=T.unsafe(nil)); end

  def download_to_cache(dependency); end

  def fetch_file(uri, *_); end

  def fetch_http(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_https(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_path(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_s3(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_size(uri); end

  def headers(); end

  def headers=(headers); end

  def https?(uri); end

  def initialize(proxy=T.unsafe(nil), dns=T.unsafe(nil), headers=T.unsafe(nil)); end

  def request(uri, request_class, last_modified=T.unsafe(nil)); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::RemoteFetcher
  def self.fetcher(); end
end

class Gem::RemoteInstallationCancelled
  extend ::T::Sig
end

class Gem::RemoteInstallationSkipped
  extend ::T::Sig
end

class Gem::RemoteSourceException
  extend ::T::Sig
end

class Gem::Request
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_files(); end

  def connection_for(uri); end

  def fetch(); end

  def initialize(uri, request_class, last_modified, pool); end

  def perform_request(request); end

  def proxy_uri(); end

  def reset(connection); end

  def user_agent(); end
end

class Gem::Request::ConnectionPools
  def close_all(); end

  def initialize(proxy_uri, cert_files); end

  def pool_for(uri); end
end

class Gem::Request::ConnectionPools
  def self.client(); end

  def self.client=(client); end
end

class Gem::Request::HTTPPool
  def cert_files(); end

  def checkin(connection); end

  def checkout(); end

  def close_all(); end

  def initialize(http_args, cert_files, proxy_uri); end

  def proxy_uri(); end
end

class Gem::Request::HTTPPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
  def self.configure_connection_for_https(connection, cert_files); end

  def self.create_with_proxy(uri, request_class, last_modified, proxy); end

  def self.get_cert_files(); end

  def self.get_proxy_from_env(scheme=T.unsafe(nil)); end

  def self.proxy_uri(proxy); end

  def self.verify_certificate(store_context); end

  def self.verify_certificate_message(error_number, cert); end
end

class Gem::RequestSet
  include ::TSort
  def always_install(); end

  def always_install=(always_install); end

  def dependencies(); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def errors(); end

  def gem(name, *reqs); end

  def git_set(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def import(deps); end

  def initialize(*deps); end

  def install(options, &block); end

  def install_dir(); end

  def install_from_gemdeps(options, &block); end

  def install_hooks(requests, options); end

  def install_into(dir, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def load_gemdeps(path, without_groups=T.unsafe(nil), installing=T.unsafe(nil)); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def resolve(set=T.unsafe(nil)); end

  def resolve_current(); end

  def resolver(); end

  def sets(); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def sorted_requests(); end

  def source_set(); end

  def specs(); end

  def specs_in(dir); end

  def tsort_each_node(&block); end

  def vendor_set(); end
end

class Gem::RequestSet::GemDependencyAPI
  def dependencies(); end

  def find_gemspec(name, path); end

  def gem(name, *requirements); end

  def gem_deps_file(); end

  def gem_git_reference(options); end

  def gemspec(options=T.unsafe(nil)); end

  def git(repository); end

  def git_set(); end

  def git_source(name, &callback); end

  def group(*groups); end

  def initialize(set, path); end

  def installing=(installing); end

  def load(); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def requires(); end

  def ruby(version, options=T.unsafe(nil)); end

  def source(url); end

  def vendor_set(); end

  def without_groups(); end

  def without_groups=(without_groups); end
  ENGINE_MAP = ::T.let(nil, ::T.untyped)
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  VERSION_MAP = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::GemDependencyAPI
end

class Gem::RequestSet::Lockfile
  def add_DEPENDENCIES(out); end

  def add_GEM(out, spec_groups); end

  def add_GIT(out, git_requests); end

  def add_PATH(out, path_requests); end

  def add_PLATFORMS(out); end

  def initialize(request_set, gem_deps_file, dependencies); end

  def platforms(); end

  def relative_path_from(dest, base); end

  def spec_groups(); end

  def write(); end
end

class Gem::RequestSet::Lockfile::ParseError
  def column(); end

  def initialize(message, column, line, path); end

  def line(); end

  def path(); end
end

class Gem::RequestSet::Lockfile::ParseError
end

class Gem::RequestSet::Lockfile::Parser
  def get(expected_types=T.unsafe(nil), expected_value=T.unsafe(nil)); end

  def initialize(tokenizer, set, platforms, filename=T.unsafe(nil)); end

  def parse(); end

  def parse_DEPENDENCIES(); end

  def parse_GEM(); end

  def parse_GIT(); end

  def parse_PATH(); end

  def parse_PLATFORMS(); end

  def parse_dependency(name, op); end
end

class Gem::RequestSet::Lockfile::Parser
end

class Gem::RequestSet::Lockfile::Tokenizer
  def empty?(); end

  def initialize(input, filename=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def make_parser(set, platforms); end

  def next_token(); end

  def peek(); end

  def shift(); end

  def skip(type); end

  def to_a(); end

  def token_pos(byte_offset); end

  def unshift(token); end
  EOF = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def column(); end

  def column=(_); end

  def line(); end

  def line=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.[](*_); end

  def self.members(); end
end

class Gem::RequestSet::Lockfile::Tokenizer
  def self.from_file(file); end
end

class Gem::RequestSet::Lockfile
  def self.build(request_set, gem_deps_file, dependencies=T.unsafe(nil)); end

  def self.requests_to_deps(requests); end
end

class Gem::RequestSet
end

class Gem::Requirement
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(version); end

  def =~(version); end

  def _tilde_requirements(); end

  def as_list(); end

  def concat(new); end

  def encode_with(coder); end

  def exact?(); end

  def for_lockfile(); end

  def init_with(coder); end

  def initialize(*requirements); end

  def marshal_dump(); end

  def marshal_load(array); end

  def none?(); end

  def prerelease?(); end

  def requirements(); end

  def satisfied_by?(version); end

  def specific?(); end

  def to_yaml_properties(); end

  def yaml_initialize(tag, vals); end
  DefaultRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement::BadRequirementError
  extend ::T::Sig
end

class Gem::Requirement
  extend ::T::Sig
  def self.create(*inputs); end

  def self.default(); end

  def self.parse(obj); end

  def self.source_set(); end
end

class Gem::Resolver
  include ::Gem::Resolver::Molinillo::UI
  include ::Gem::Resolver::Molinillo::SpecificationProvider
  def activation_request(dep, possible); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def explain(stage, *data); end

  def explain_list(stage); end

  def find_possible(dependency); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def initialize(needed, set=T.unsafe(nil)); end

  def missing(); end

  def requests(s, act, reqs=T.unsafe(nil)); end

  def resolve(); end

  def select_local_platforms(specs); end

  def skip_gems(); end

  def skip_gems=(skip_gems); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def stats(); end
  DEBUG_RESOLVER = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::APISet
  def dep_uri(); end

  def initialize(dep_uri=T.unsafe(nil)); end

  def prefetch_now(); end

  def source(); end

  def uri(); end

  def versions(name); end
end

class Gem::Resolver::APISet
end

class Gem::Resolver::APISpecification
  def ==(other); end

  def initialize(set, api_data); end
end

class Gem::Resolver::APISpecification
end

class Gem::Resolver::ActivationRequest
  def ==(other); end

  def development?(); end

  def download(path); end

  def full_name(); end

  def full_spec(); end

  def initialize(spec, request, others_possible=T.unsafe(nil)); end

  def installed?(); end

  def name(); end

  def others_possible?(); end

  def parent(); end

  def request(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::ActivationRequest
end

class Gem::Resolver::BestSet
  def initialize(sources=T.unsafe(nil)); end

  def pick_sets(); end

  def replace_failed_api_set(error); end
end

class Gem::Resolver::BestSet
end

class Gem::Resolver::ComposedSet
  def initialize(*sets); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def sets(); end
end

class Gem::Resolver::ComposedSet
end

class Gem::Resolver::Conflict
  def ==(other); end

  def activated(); end

  def conflicting_dependencies(); end

  def dependency(); end

  def explain(); end

  def explanation(); end

  def failed_dep(); end

  def for_spec?(spec); end

  def initialize(dependency, activated, failed_dep=T.unsafe(nil)); end

  def request_path(current); end

  def requester(); end
end

class Gem::Resolver::Conflict
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::DependencyRequest
  def ==(other); end

  def dependency(); end

  def development?(); end

  def explicit?(); end

  def implicit?(); end

  def initialize(dependency, requester); end

  def match?(spec, allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def name(); end

  def request_context(); end

  def requester(); end

  def requirement(); end

  def type(); end
end

class Gem::Resolver::DependencyRequest
end

class Gem::Resolver::GitSet
  def add_git_gem(name, repository, reference, submodules); end

  def add_git_spec(name, version, repository, reference, submodules); end

  def need_submodules(); end

  def repositories(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end
end

class Gem::Resolver::GitSet
end

class Gem::Resolver::GitSpecification
  def ==(other); end

  def add_dependency(dependency); end
end

class Gem::Resolver::GitSpecification
end

class Gem::Resolver::IndexSet
  def initialize(source=T.unsafe(nil)); end
end

class Gem::Resolver::IndexSet
end

class Gem::Resolver::IndexSpecification
  def initialize(set, name, version, source, platform); end
end

class Gem::Resolver::IndexSpecification
end

class Gem::Resolver::InstalledSpecification
  def ==(other); end
end

class Gem::Resolver::InstalledSpecification
end

class Gem::Resolver::InstallerSet
  def add_always_install(dependency); end

  def add_local(dep_name, spec, source); end

  def always_install(); end

  def consider_local?(); end

  def consider_remote?(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def ignore_installed(); end

  def ignore_installed=(ignore_installed); end

  def initialize(domain); end

  def load_spec(name, ver, platform, source); end

  def local?(dep_name); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def remote_set(); end
end

class Gem::Resolver::InstallerSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def add(name, version, platform); end

  def initialize(sources); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::LockSet
end

class Gem::Resolver::LockSpecification
  def add_dependency(dependency); end

  def initialize(set, name, version, sources, platform); end

  def sources(); end
end

class Gem::Resolver::LockSpecification
end

module Gem::Resolver::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(nodes); end
end

class Gem::Resolver::Molinillo::CircularDependencyError
end

module Gem::Resolver::Molinillo::Delegates
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
end

class Gem::Resolver::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Resolver::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Resolver::Molinillo::DependencyState
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
  include ::Gem::Resolver::Molinillo::Delegates::ResolutionState
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
end

class Gem::Resolver::Molinillo::Resolver
end

class Gem::Resolver::Molinillo::ResolverError
end

class Gem::Resolver::Molinillo::ResolverError
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Resolver::Molinillo::UI
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::VersionConflict
  def conflicts(); end

  def initialize(conflicts); end
end

class Gem::Resolver::Molinillo::VersionConflict
end

module Gem::Resolver::Molinillo
  extend ::T::Sig
end

class Gem::Resolver::RequirementList
  include ::Enumerable
  def add(req); end

  def each(&blk); end

  def empty?(); end

  def next5(); end

  def remove(); end

  def size(); end
end

class Gem::Resolver::RequirementList
end

class Gem::Resolver::Set
  def errors(); end

  def errors=(errors); end

  def find_all(req); end

  def prefetch(reqs); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def remote?(); end
end

class Gem::Resolver::Set
end

class Gem::Resolver::SourceSet
  def add_source_gem(name, source); end
end

class Gem::Resolver::SourceSet
end

class Gem::Resolver::SpecSpecification
  def initialize(set, spec, source=T.unsafe(nil)); end
end

class Gem::Resolver::SpecSpecification
end

class Gem::Resolver::Specification
  def dependencies(); end

  def download(options); end

  def fetch_development_dependencies(); end

  def full_name(); end

  def install(options=T.unsafe(nil)); end

  def installable_platform?(); end

  def local?(); end

  def name(); end

  def platform(); end

  def set(); end

  def source(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::Specification
end

class Gem::Resolver::Stats
  def backtracking!(); end

  def display(); end

  def iteration!(); end

  def record_depth(stack); end

  def record_requirements(reqs); end

  def requirement!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Stats
end

class Gem::Resolver::VendorSet
  def add_vendor_gem(name, directory); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::VendorSet
end

class Gem::Resolver::VendorSpecification
  def ==(other); end
end

class Gem::Resolver::VendorSpecification
end

class Gem::Resolver
  def self.compose_sets(*sets); end

  def self.for_current_gems(needed); end
end

class Gem::RubyVersionMismatch
  extend ::T::Sig
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::Security
  AlmostNoSecurity = ::T.let(nil, ::T.untyped)
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HighSecurity = ::T.let(nil, ::T.untyped)
  KEY_CIPHER = ::T.let(nil, ::T.untyped)
  KEY_LENGTH = ::T.let(nil, ::T.untyped)
  LowSecurity = ::T.let(nil, ::T.untyped)
  MediumSecurity = ::T.let(nil, ::T.untyped)
  NoSecurity = ::T.let(nil, ::T.untyped)
  ONE_DAY = ::T.let(nil, ::T.untyped)
  ONE_YEAR = ::T.let(nil, ::T.untyped)
  Policies = ::T.let(nil, ::T.untyped)
  SigningPolicy = ::T.let(nil, ::T.untyped)
end

class Gem::Security::DIGEST_ALGORITHM
  def initialize(data=T.unsafe(nil)); end
end

class Gem::Security::DIGEST_ALGORITHM
  def self.digest(data); end

  def self.hexdigest(data); end
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
  DEFAULT_PERMISSIONS = ::T.let(nil, ::T.untyped)
end

class Gem::Security::TrustDir
end

module Gem::Security
  extend ::T::Sig
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SilentUI
  def initialize(); end
end

class Gem::SilentUI
end

class Gem::Source
  include ::Comparable
  def ==(other); end

  def cache_dir(uri); end

  def dependency_resolver_set(); end

  def download(spec, dir=T.unsafe(nil)); end

  def eql?(other); end

  def fetch_spec(name_tuple); end

  def initialize(uri); end

  def load_specs(type); end

  def update_cache?(); end

  def uri(); end
  FILES = ::T.let(nil, ::T.untyped)
end

class Gem::Source::Git
  def base_dir(); end

  def cache(); end

  def checkout(); end

  def dir_shortref(); end

  def download(full_spec, path); end

  def initialize(name, repository, reference, submodules=T.unsafe(nil)); end

  def install_dir(); end

  def name(); end

  def need_submodules(); end

  def reference(); end

  def remote(); end

  def remote=(remote); end

  def repo_cache_dir(); end

  def repository(); end

  def rev_parse(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end

  def uri_hash(); end
end

class Gem::Source::Git
end

class Gem::Source::Installed
  def download(spec, path); end

  def initialize(); end
end

class Gem::Source::Installed
end

class Gem::Source::Local
  def download(spec, cache_dir=T.unsafe(nil)); end

  def fetch_spec(name); end

  def find_gem(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def initialize(); end
end

class Gem::Source::Local
end

class Gem::Source::Lock
  def initialize(source); end

  def wrapped(); end
end

class Gem::Source::Lock
end

class Gem::Source::SpecificFile
  def fetch_spec(name); end

  def initialize(file); end

  def load_specs(*a); end

  def path(); end

  def spec(); end
end

class Gem::Source::SpecificFile
end

class Gem::Source::Vendor
  def initialize(path); end
end

class Gem::Source::Vendor
end

class Gem::Source
end

class Gem::SourceFetchProblem
  def error(); end

  def exception(); end

  def initialize(source, error); end

  def source(); end

  def wordy(); end
end

class Gem::SourceFetchProblem
  extend ::T::Sig
end

class Gem::SourceList
  include ::Enumerable
  def <<(obj); end

  def ==(other); end

  def clear(); end

  def delete(source); end

  def each(&blk); end

  def each_source(&b); end

  def empty?(); end

  def first(); end

  def include?(other); end

  def replace(other); end

  def sources(); end

  def to_a(); end

  def to_ary(); end
end

class Gem::SourceList
  def self.from(ary); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::SpecificGemNotFoundException
  def errors(); end

  def initialize(name, version, errors=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::SpecificGemNotFoundException
  extend ::T::Sig
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def _deprecated_default_executable(); end

  def _deprecated_default_executable=(_deprecated_default_executable); end

  def _deprecated_has_rdoc(); end

  def _deprecated_has_rdoc=(ignored); end

  def _deprecated_has_rdoc?(*args, &block); end

  def _dump(limit); end

  def abbreviate(); end

  def activate(); end

  def activate_dependencies(); end

  def activated(); end

  def activated=(activated); end

  def add_bindir(executables); end

  def add_dependency(gem, *requirements); end

  def add_development_dependency(gem, *requirements); end

  def add_runtime_dependency(gem, *requirements); end

  def add_self_to_load_path(); end

  def author(); end

  def author=(o); end

  def authors(); end

  def authors=(value); end

  def autorequire(); end

  def autorequire=(autorequire); end

  def bin_dir(); end

  def bin_file(name); end

  def bindir(); end

  def bindir=(bindir); end

  def build_args(); end

  def build_extensions(); end

  def build_info_dir(); end

  def build_info_file(); end

  def cache_dir(); end

  def cache_file(); end

  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def conficts_when_loaded_with?(list_of_specs); end

  def conflicts(); end

  def date(); end

  def date=(date); end

  def default_executable(*args, &block); end

  def default_executable=(*args, &block); end

  def default_value(name); end

  def dependencies(); end

  def dependent_gems(); end

  def dependent_specs(); end

  def description(); end

  def description=(str); end

  def development_dependencies(); end

  def doc_dir(type=T.unsafe(nil)); end

  def email(); end

  def email=(email); end

  def encode_with(coder); end

  def eql?(other); end

  def executable(); end

  def executable=(o); end

  def executables(); end

  def executables=(value); end

  def extensions(); end

  def extensions=(extensions); end

  def extra_rdoc_files(); end

  def extra_rdoc_files=(files); end

  def file_name(); end

  def files(); end

  def files=(files); end

  def for_cache(); end

  def git_version(); end

  def groups(); end

  def has_conflicts?(); end

  def has_rdoc(*args, &block); end

  def has_rdoc=(*args, &block); end

  def has_rdoc?(*args, &block); end

  def has_test_suite?(); end

  def has_unit_tests?(); end

  def homepage(); end

  def homepage=(homepage); end

  def init_with(coder); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def installed_by_version(); end

  def installed_by_version=(version); end

  def keep_only_files_and_directories(); end

  def lib_files(); end

  def license(); end

  def license=(o); end

  def licenses(); end

  def licenses=(licenses); end

  def load_paths(); end

  def location(); end

  def location=(location); end

  def mark_version(); end

  def metadata(); end

  def metadata=(metadata); end

  def method_missing(sym, *a, &b); end

  def missing_extensions?(); end

  def name=(name); end

  def name_tuple(); end

  def nondevelopment_dependencies(); end

  def normalize(); end

  def original_name(); end

  def original_platform(); end

  def original_platform=(original_platform); end

  def platform=(platform); end

  def post_install_message(); end

  def post_install_message=(post_install_message); end

  def raise_if_conflicts(); end

  def rdoc_options(); end

  def rdoc_options=(options); end

  def relative_loaded_from(); end

  def relative_loaded_from=(relative_loaded_from); end

  def remote(); end

  def remote=(remote); end

  def require_path(); end

  def require_path=(path); end

  def require_paths=(val); end

  def required_ruby_version(); end

  def required_ruby_version=(req); end

  def required_rubygems_version(); end

  def required_rubygems_version=(req); end

  def requirements(); end

  def requirements=(req); end

  def reset_nil_attributes_to_default(); end

  def rg_extension_dir(); end

  def rg_full_gem_path(); end

  def rg_loaded_from(); end

  def ri_dir(); end

  def rubyforge_project=(rubyforge_project); end

  def rubygems_version(); end

  def rubygems_version=(rubygems_version); end

  def runtime_dependencies(); end

  def sanitize(); end

  def sanitize_string(string); end

  def satisfies_requirement?(dependency); end

  def signing_key(); end

  def signing_key=(signing_key); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def spec_dir(); end

  def spec_file(); end

  def spec_name(); end

  def specification_version(); end

  def specification_version=(specification_version); end

  def summary(); end

  def summary=(str); end

  def test_file(); end

  def test_file=(file); end

  def test_files(); end

  def test_files=(files); end

  def to_gemfile(path=T.unsafe(nil)); end

  def to_ruby(); end

  def to_ruby_for_cache(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def traverse(trail=T.unsafe(nil), visited=T.unsafe(nil), &block); end

  def validate(packaging=T.unsafe(nil), strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end

  def version=(version); end

  def yaml_initialize(tag, vals); end
  DateLike = ::T.let(nil, ::T.untyped)
  DateTimeFormat = ::T.let(nil, ::T.untyped)
  INITIALIZE_CODE_FOR_DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::T::Sig
  extend ::Enumerable
  extend ::Gem::Deprecate
  def self._all(); end

  def self._clear_load_cache(); end

  def self._latest_specs(specs, prerelease=T.unsafe(nil)); end

  def self._load(str); end

  def self._resort!(specs); end

  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.all(); end

  def self.all=(specs); end

  def self.all_names(); end

  def self.array_attributes(); end

  def self.attribute_names(); end

  def self.dirs(); end

  def self.dirs=(dirs); end

  def self.each(&blk); end

  def self.each_gemspec(dirs); end

  def self.each_spec(dirs); end

  def self.find_active_stub_by_path(path); end

  def self.find_all_by_full_name(full_name); end

  def self.find_all_by_name(name, *requirements); end

  def self.find_by_name(name, *requirements); end

  def self.find_by_path(path); end

  def self.find_in_unresolved(path); end

  def self.find_in_unresolved_tree(path); end

  def self.find_inactive_by_path(path); end

  def self.from_yaml(input); end

  def self.latest_specs(prerelease=T.unsafe(nil)); end

  def self.load(file); end

  def self.load_defaults(); end

  def self.non_nil_attributes(); end

  def self.normalize_yaml_input(input); end

  def self.outdated(); end

  def self.outdated_and_latest_version(); end

  def self.remove_spec(spec); end

  def self.required_attribute?(name); end

  def self.required_attributes(); end

  def self.reset(); end

  def self.stubs(); end

  def self.stubs_for(name); end

  def self.unresolved_deps(); end
end

class Gem::SpecificationPolicy
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end

  def _gets_noecho(); end

  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(question); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def backtrace(exception); end

  def choose_from_list(question, list); end

  def close(); end

  def debug(*args, &block); end

  def download_reporter(*args); end

  def errs(); end

  def initialize(in_stream, out_stream, err_stream=T.unsafe(nil), usetty=T.unsafe(nil)); end

  def ins(); end

  def outs(); end

  def progress_reporter(*args); end

  def require_io_console(); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(status=T.unsafe(nil)); end

  def tty?(); end
end

class Gem::StreamUI
  extend ::Gem::Deprecate
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification::StubLine
  extend ::T::Sig
end

class Gem::StubSpecification
  extend ::T::Sig
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::SystemExitException
  def exit_code(); end

  def exit_code=(exit_code); end

  def initialize(exit_code); end
end

class Gem::SystemExitException
  extend ::T::Sig
end

module Gem::Text
  def clean_text(text); end

  def format_text(text, wrap, indent=T.unsafe(nil)); end

  def levenshtein_distance(str1, str2); end

  def min3(a, b, c); end

  def truncate_text(text, description, max_length=T.unsafe(nil)); end
end

module Gem::Text
  extend ::T::Sig
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

class Gem::UnsatisfiableDependencyError
  def dependency(); end

  def errors(); end

  def errors=(errors); end

  def initialize(dep, platform_mismatch=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::UnsatisfiableDependencyError
  extend ::T::Sig
end

class Gem::UriFormatter
  def escape(); end

  def initialize(uri); end

  def normalize(); end

  def unescape(); end

  def uri(); end
end

class Gem::UriFormatter
end

module Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(prompt); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def choose_from_list(question, list); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(exit_code=T.unsafe(nil)); end

  def verbose(msg=T.unsafe(nil)); end
end

module Gem::UserInteraction
  extend ::T::Sig
end

module Gem::Util
end

module Gem::Util
  extend ::T::Sig
  def self.glob_files_in_dir(glob, base_path); end

  def self.gunzip(data); end

  def self.gzip(data); end

  def self.inflate(data); end

  def self.popen(*command); end

  def self.silent_system(*command); end

  def self.traverse_parents(directory, &block); end
end

class Gem::VerificationError
  extend ::T::Sig
end

class Gem::Version
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def _segments(); end

  def _split_segments(); end

  def _version(); end

  def approximate_recommendation(); end

  def bump(); end

  def canonical_segments(); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def marshal_dump(); end

  def marshal_load(array); end

  def prerelease?(); end

  def release(); end

  def segments(); end

  def to_yaml_properties(); end

  def version(); end

  def yaml_initialize(tag, map); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::Version
  extend ::T::Sig
  def self.correct?(version); end

  def self.create(input); end

  def self.new(version); end
end

module Gem
  extend ::T::Sig
  def self._deprecated_detect_gemdeps(path=T.unsafe(nil)); end

  def self._deprecated_gunzip(data); end

  def self._deprecated_gzip(data); end

  def self._deprecated_inflate(data); end

  def self.activate_bin_path(name, *args); end

  def self.default_ext_dir_for(base_dir); end

  def self.default_gems_use_full_paths?(); end

  def self.default_spec_cache_dir(); end

  def self.deflate(data); end

  def self.detect_gemdeps(*args, &block); end

  def self.dir(); end

  def self.done_installing(&hook); end

  def self.done_installing_hooks(); end

  def self.ensure_default_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_subdirectories(dir, mode, subdirs); end

  def self.env_requirement(gem_name); end

  def self.extension_api_version(); end

  def self.find_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_files_from_load_path(glob); end

  def self.find_latest_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_unresolved_default_spec(path); end

  def self.finish_resolve(*_); end

  def self.gemdeps(); end

  def self.gunzip(*args, &block); end

  def self.gzip(*args, &block); end

  def self.host(); end

  def self.host=(host); end

  def self.inflate(*args, &block); end

  def self.install(name, version=T.unsafe(nil), *options); end

  def self.install_extension_in_lib(); end

  def self.latest_rubygems_version(); end

  def self.latest_spec_for(name); end

  def self.latest_version_for(name); end

  def self.load_env_plugins(); end

  def self.load_path_insert_index(); end

  def self.load_plugin_files(plugins); end

  def self.load_plugins(); end

  def self.load_yaml(); end

  def self.loaded_specs(); end

  def self.location_of_caller(depth=T.unsafe(nil)); end

  def self.marshal_version(); end

  def self.needs(); end

  def self.operating_system_defaults(); end

  def self.path(); end

  def self.path_separator(); end

  def self.paths(); end

  def self.paths=(env); end

  def self.platform_defaults(); end

  def self.platforms(); end

  def self.platforms=(platforms); end

  def self.post_build(&hook); end

  def self.post_build_hooks(); end

  def self.post_install(&hook); end

  def self.post_install_hooks(); end

  def self.post_reset(&hook); end

  def self.post_reset_hooks(); end

  def self.post_uninstall(&hook); end

  def self.post_uninstall_hooks(); end

  def self.pre_install(&hook); end

  def self.pre_install_hooks(); end

  def self.pre_reset(&hook); end

  def self.pre_reset_hooks(); end

  def self.pre_uninstall(&hook); end

  def self.pre_uninstall_hooks(); end

  def self.prefix(); end

  def self.read_binary(path); end

  def self.refresh(); end

  def self.register_default_spec(spec); end

  def self.remove_unresolved_default_spec(spec); end

  def self.ruby(); end

  def self.ruby_api_version(); end

  def self.ruby_engine(); end

  def self.ruby_version(); end

  def self.rubygems_version(); end

  def self.sources(); end

  def self.sources=(new_sources); end

  def self.spec_cache_dir(); end

  def self.suffix_pattern(); end

  def self.suffixes(); end

  def self.time(msg, width=T.unsafe(nil), display=T.unsafe(nil)); end

  def self.try_activate(path); end

  def self.ui(); end

  def self.use_gemdeps(path=T.unsafe(nil)); end

  def self.use_paths(home, *paths); end

  def self.user_dir(); end

  def self.user_home(); end

  def self.vendor_dir(); end

  def self.win_platform?(); end

  def self.write_binary(path, data); end
end

module GlobalID::Identification
  extend ::T::Sig
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  extend ::T::Sig
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class HTMLSelector
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class Hash
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def fetch_values(*_); end

  def filter!(); end

  def flatten(*_); end

  def index(_); end

  def merge!(*_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  extend ::T::Sig
  def self.from_trusted_xml(xml); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Base
  extend ::T::Sig
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
  extend ::T::Sig
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
  extend ::T::Sig
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
  extend ::T::Sig
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
  extend ::T::Sig
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
  extend ::T::Sig
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  extend ::T::Sig
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
  extend ::T::Sig
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
  extend ::T::Sig
end

module I18n::Backend::InterpolationCompiler
  extend ::T::Sig
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
  extend ::T::Sig
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
  extend ::T::Sig
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  extend ::T::Sig
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
  extend ::T::Sig
end

module I18n::Backend::Simple::Implementation
  extend ::T::Sig
end

module I18n::Backend::Transliterator
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Transliterator
  extend ::T::Sig
end

module I18n::Backend
  extend ::T::Sig
end

module I18n::Base
  extend ::T::Sig
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
  extend ::T::Sig
end

module I18n::Gettext
  extend ::T::Sig
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::HashRefinements
  extend ::T::Sig
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
  extend ::T::Sig
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  extend ::T::Sig
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  extend ::T::Sig
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
  extend ::T::Sig
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::MissingTranslation::Base
  extend ::T::Sig
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  extend ::T::Sig
  def self.included(base); end
end

module I18n::Tests
  extend ::T::Sig
end

module I18n
  extend ::T::Sig
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

class IO::EAGAINWaitReadable
  extend ::T::Sig
end

class IO::EAGAINWaitWritable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitReadable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitWritable
  extend ::T::Sig
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

module IO::WaitReadable
  extend ::T::Sig
end

module IO::WaitWritable
  extend ::T::Sig
end

class IO
  extend ::T::Sig
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end

  def self.pipe(*_); end

end

class IOError
  extend ::T::Sig
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class IPSocket
  extend ::T::Sig
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  extend ::T::Sig
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  extend ::T::Sig
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
  extend ::T::Sig
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  extend ::T::Sig
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  extend ::T::Sig
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

class IndexError
  extend ::T::Sig
end

module IniParse
  VERSION = ::T.let(nil, ::T.untyped)
end

module IniParse::LineCollection
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module IniParse::LineCollection
  extend ::T::Sig
end

module IniParse::Lines::Line
  extend ::T::Sig
end

module IniParse::Lines
  extend ::T::Sig
end

module IniParse
  extend ::T::Sig
end

class Integer
  include ::ActiveSupport::NumericWithFormat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  extend ::T::Sig
  def self.sqrt(_); end
end

class Interrupt
  extend ::T::Sig
end

class JSON::CircularDatastructure
  extend ::T::Sig
end

module JSON::Ext
end

module JSON::Ext::Generator
end

module JSON::Ext::Generator::GeneratorMethods
end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Array
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Float
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Float
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Object
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Object
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::String
  def to_json(*_); end

  def to_json_raw(*_); end

  def to_json_raw_object(); end
end

module JSON::Ext::Generator::GeneratorMethods::String
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods
  extend ::T::Sig
end

class JSON::Ext::Generator::State
  def [](_); end

  def []=(_, _1); end

  def allow_nan?(); end

  def array_nl(); end

  def array_nl=(array_nl); end

  def ascii_only?(); end

  def buffer_initial_length(); end

  def buffer_initial_length=(buffer_initial_length); end

  def check_circular?(); end

  def configure(_); end

  def depth(); end

  def depth=(depth); end

  def generate(_); end

  def indent(); end

  def indent=(indent); end

  def initialize(*_); end

  def max_nesting(); end

  def max_nesting=(max_nesting); end

  def merge(_); end

  def object_nl(); end

  def object_nl=(object_nl); end

  def space(); end

  def space=(space); end

  def space_before(); end

  def space_before=(space_before); end

  def to_h(); end

  def to_hash(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

module JSON::Ext::Generator
  extend ::T::Sig
end

class JSON::Ext::Parser
  def initialize(*_); end

  def parse(); end

  def source(); end
end

class JSON::Ext::Parser
end

module JSON::Ext
  extend ::T::Sig
end

class JSON::GeneratorError
  extend ::T::Sig
end

class JSON::GenericObject
  extend ::T::Sig
end

class JSON::JSONError
  extend ::T::Sig
end

class JSON::MissingUnicodeSupport
  extend ::T::Sig
end

class JSON::NestingError
  extend ::T::Sig
end

JSON::Parser = JSON::Ext::Parser

class JSON::ParserError
  extend ::T::Sig
end

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  extend ::T::Sig
end

JSONTree = Psych::Visitors::JSONTree

class Jbuilder
  BLANK = ::T.let(nil, ::T.untyped)
  NON_ENUMERABLES = ::T.let(nil, ::T.untyped)
end

module Jbuilder::DependencyTrackerMethods
  DIRECT_RENDERS = ::T.let(nil, ::T.untyped)
  INDIRECT_RENDERS = ::T.let(nil, ::T.untyped)
end

module Jbuilder::DependencyTrackerMethods
  extend ::T::Sig
end

module Jquery::Rails
  JQUERY_2_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_3_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_UJS_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Jquery::Rails
  extend ::T::Sig
end

module Jquery
  extend ::T::Sig
end

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def then(); end

  def yield_self(); end
end

module Kernel
  extend ::T::Sig
  def self.`(_); end

  def self.at_exit(); end

  def self.load(*_); end

  def self.require(_); end
end

class KeyError
  def key(); end

  def receiver(); end
end

class KeyError
  extend ::T::Sig
end

class LoadError
  def path(); end
end

class LoadError
  extend ::T::Sig
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class LocalJumpError
  extend ::T::Sig
end

class Logger
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Error
  extend ::T::Sig
end

class Logger::Formatter
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  extend ::T::Sig
end

class Logger::LogDevice
  include ::MonitorMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Logger::LogDevice
  extend ::T::Sig
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logger::Period
  extend ::T::Sig
end

module Logger::Severity
  extend ::T::Sig
end

class Logger::ShiftingError
  extend ::T::Sig
end

class Logger
  extend ::T::Sig
end

module LoggerSilence
  extend ::T::Sig
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::DocumentDecorator
  extend ::T::Sig
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
  extend ::T::Sig
end

module Loofah::HTML
  extend ::T::Sig
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  extend ::T::Sig
end

module Loofah::HTML5::WhiteList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::WhiteList
  extend ::T::Sig
end

module Loofah::HTML5
  extend ::T::Sig
end

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

module Loofah::LibxmlWorkarounds
  extend ::T::Sig
end

module Loofah::MetaHelpers
  extend ::T::Sig
end

module Loofah::ScrubBehavior::Node
  extend ::T::Sig
end

module Loofah::ScrubBehavior::NodeSet
  extend ::T::Sig
end

module Loofah::ScrubBehavior
  extend ::T::Sig
end

class Loofah::Scrubber
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  extend ::T::Sig
end

module Loofah::TextBehavior
  extend ::T::Sig
end

module Loofah::XML
  extend ::T::Sig
end

module Loofah
  extend ::T::Sig
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marcel
  extend ::T::Sig
end

module Marshal
  extend ::T::Sig
  extend ::ActiveSupport::MarshalWithAutoloading
  def self.restore(*_); end
end

class MatchData
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def named_captures(); end
end

class MatchData
  extend ::T::Sig
end

class Math::DomainError
  extend ::T::Sig
end

module Math
  extend ::T::Sig
end

class Method
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def [](*_); end

  def arity(); end

  def clone(); end

  def curry(*_); end

  def name(); end

  def original_name(); end

  def owner(); end

  def parameters(); end

  def receiver(); end

  def super_method(); end

  def unbind(); end
end

class Method
  extend ::T::Sig
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  extend ::T::Sig
end

module MethodSource::CodeHelpers
  extend ::T::Sig
end

module MethodSource::MethodExtensions
  extend ::T::Sig
end

module MethodSource::ReeSourceLocation
  extend ::T::Sig
end

module MethodSource::SourceLocation::MethodExtensions
  extend ::T::Sig
end

module MethodSource::SourceLocation::ProcExtensions
  extend ::T::Sig
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  extend ::T::Sig
end

module MethodSource::SourceLocation
  extend ::T::Sig
end

module MethodSource
  extend ::T::Sig
end

Methods = T::Private::Methods

class Micropost
  include ::Micropost::GeneratedAssociationMethods
  def autosave_associated_records_for_user(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

module Micropost::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def user(); end

  def user=(value); end
end

module Micropost::GeneratedAssociationMethods
  extend ::T::Sig
end

class Micropost
end

class MicropostsController
  def create(); end

  def destroy(); end

  def edit(); end

  def index(); end

  def new(); end

  def show(); end

  def update(); end
end

class MicropostsController
end

module MicropostsHelper
  extend ::T::Sig
end

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

module Mime
  extend ::T::Sig
end

module Minitest
end

MiniTest::Assertions = Minitest::Assertions

MiniTest::Guard = Minitest::Guard

MiniTest::Reportable = Minitest::Reportable

MiniTest::Runnable = Minitest::Runnable

MiniTest::Test = Minitest::Test

module Minitest
end

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  extend ::T::Sig
end

class Minitest::BacktraceFilter
  MT_RE = ::T.let(nil, ::T.untyped)
end

module Minitest::Guard
  extend ::T::Sig
end

module Minitest::Parallel::Test::ClassMethods
  extend ::T::Sig
end

module Minitest::Parallel::Test
  extend ::T::Sig
end

module Minitest::Parallel
  extend ::T::Sig
end

module Minitest::Reportable
  extend ::T::Sig
end

class Minitest::Runnable
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Test
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  extend ::T::Sig
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

module Minitest
  extend ::T::Sig
end

class Module
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def deprecate_constant(*_); end

  def undef_method(*_); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  extend ::T::Sig
end

class Module
  extend ::T::Sig
  def self.used_modules(); end
end

class Monitor
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def enter(); end

  def exit(); end

  def try_enter(); end
end

class Monitor
  extend ::T::Sig
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

class MonitorMixin::ConditionVariable::Timeout
  extend ::T::Sig
end

class MonitorMixin::ConditionVariable
  extend ::T::Sig
end

module MonitorMixin
  extend ::T::Sig
  def self.extend_object(obj); end
end

Mutex = Thread::Mutex

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module Mutex_m
  extend ::T::Sig
end

class NameError
  def name(); end

  def receiver(); end
end

class NameError
  extend ::T::Sig
end

class NilClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_d(); end

  def to_i(); end
end

class NilClass
  extend ::T::Sig
end

class NoMemoryError
  extend ::T::Sig
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class NoMethodError
  extend ::T::Sig
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
  extend ::T::Sig
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  extend ::T::Sig
end

module Nokogiri::Decorators
  extend ::T::Sig
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

module Nokogiri::HTML::SAX
  extend ::T::Sig
end

module Nokogiri::HTML
  extend ::T::Sig
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::PP::CharacterData
  extend ::T::Sig
end

module Nokogiri::XML::PP::Node
  extend ::T::Sig
end

module Nokogiri::XML::PP
  extend ::T::Sig
end

class Nokogiri::XML::ParseOptions
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::SAX
  extend ::T::Sig
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  extend ::T::Sig
end

module Nokogiri::XML
  extend ::T::Sig
end

module Nokogiri::XSLT
  extend ::T::Sig
end

module Nokogiri
  extend ::T::Sig
end

class NotImplementedError
  extend ::T::Sig
end

class Numeric
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def finite?(); end

  def infinite?(); end

  def negative?(); end

  def positive?(); end

  EXABYTE = ::T.let(nil, ::T.untyped)
  GIGABYTE = ::T.let(nil, ::T.untyped)
  KILOBYTE = ::T.let(nil, ::T.untyped)
  MEGABYTE = ::T.let(nil, ::T.untyped)
  PETABYTE = ::T.let(nil, ::T.untyped)
  TERABYTE = ::T.let(nil, ::T.untyped)
end

class Numeric
  extend ::T::Sig
end

class Object
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::PP::ObjectMixin
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  extend ::T::Sig
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class ObjectSpace::WeakMap
  extend ::T::Sig
end

module ObjectSpace
  extend ::T::Sig
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class OpenSSL::ASN1::ASN1Data
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::ASN1::ASN1Data
  extend ::T::Sig
end

class OpenSSL::ASN1::ASN1Error
  extend ::T::Sig
end

class OpenSSL::ASN1::BMPString
  extend ::T::Sig
end

class OpenSSL::ASN1::BitString
  extend ::T::Sig
end

class OpenSSL::ASN1::Boolean
  extend ::T::Sig
end

class OpenSSL::ASN1::Constructive
  extend ::T::Sig
end

class OpenSSL::ASN1::EndOfContent
  extend ::T::Sig
end

class OpenSSL::ASN1::Enumerated
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralString
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralizedTime
  extend ::T::Sig
end

class OpenSSL::ASN1::GraphicString
  extend ::T::Sig
end

class OpenSSL::ASN1::IA5String
  extend ::T::Sig
end

class OpenSSL::ASN1::ISO64String
  extend ::T::Sig
end

class OpenSSL::ASN1::Integer
  extend ::T::Sig
end

class OpenSSL::ASN1::Null
  extend ::T::Sig
end

class OpenSSL::ASN1::NumericString
  extend ::T::Sig
end

class OpenSSL::ASN1::ObjectId
  extend ::T::Sig
end

class OpenSSL::ASN1::OctetString
  extend ::T::Sig
end

class OpenSSL::ASN1::Primitive
  extend ::T::Sig
end

class OpenSSL::ASN1::PrintableString
  extend ::T::Sig
end

class OpenSSL::ASN1::Sequence
  extend ::T::Sig
end

class OpenSSL::ASN1::Set
  extend ::T::Sig
end

class OpenSSL::ASN1::T61String
  extend ::T::Sig
end

class OpenSSL::ASN1::UTCTime
  extend ::T::Sig
end

class OpenSSL::ASN1::UTF8String
  extend ::T::Sig
end

class OpenSSL::ASN1::UniversalString
  extend ::T::Sig
end

class OpenSSL::ASN1::VideotexString
  extend ::T::Sig
end

module OpenSSL::ASN1
  extend ::T::Sig
end

class OpenSSL::BN
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

class OpenSSL::BN
  extend ::T::Sig
end

class OpenSSL::BNError
  extend ::T::Sig
end

module OpenSSL::Buffering
  extend ::T::Sig
end

class OpenSSL::Cipher
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Cipher::AES
  extend ::T::Sig
end

class OpenSSL::Cipher::AES128
  extend ::T::Sig
end

class OpenSSL::Cipher::AES192
  extend ::T::Sig
end

class OpenSSL::Cipher::AES256
  extend ::T::Sig
end

class OpenSSL::Cipher::BF
  extend ::T::Sig
end

class OpenSSL::Cipher::CAST5
  extend ::T::Sig
end

class OpenSSL::Cipher::CipherError
  extend ::T::Sig
end

class OpenSSL::Cipher::DES
  extend ::T::Sig
end

class OpenSSL::Cipher::IDEA
  extend ::T::Sig
end

class OpenSSL::Cipher::RC2
  extend ::T::Sig
end

class OpenSSL::Cipher::RC4
  extend ::T::Sig
end

class OpenSSL::Cipher::RC5
  extend ::T::Sig
end

class OpenSSL::Cipher
  extend ::T::Sig
end

class OpenSSL::Config
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Config
  extend ::T::Sig
end

class OpenSSL::ConfigError
  extend ::T::Sig
end

class OpenSSL::Digest
  extend ::T::Sig
end

class OpenSSL::Engine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Engine::EngineError
  extend ::T::Sig
end

class OpenSSL::Engine
  extend ::T::Sig
end

module OpenSSL::ExtConfig
  extend ::T::Sig
end

class OpenSSL::HMAC
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::HMAC
  extend ::T::Sig
end

class OpenSSL::HMACError
  extend ::T::Sig
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  extend ::T::Sig
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::Netscape::SPKI
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Netscape::SPKI
  extend ::T::Sig
end

class OpenSSL::Netscape::SPKIError
  extend ::T::Sig
end

module OpenSSL::Netscape
  extend ::T::Sig
end

class OpenSSL::OCSP::BasicResponse
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::BasicResponse
  extend ::T::Sig
end

class OpenSSL::OCSP::CertificateId
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::CertificateId
  extend ::T::Sig
end

class OpenSSL::OCSP::OCSPError
  extend ::T::Sig
end

class OpenSSL::OCSP::Request
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def signed?(); end
end

class OpenSSL::OCSP::Request
  extend ::T::Sig
end

class OpenSSL::OCSP::Response
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::Response
  extend ::T::Sig
end

class OpenSSL::OCSP::SingleResponse
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::SingleResponse
  extend ::T::Sig
end

module OpenSSL::OCSP
  extend ::T::Sig
end

class OpenSSL::OpenSSLError
  extend ::T::Sig
end

class OpenSSL::PKCS12
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS12::PKCS12Error
  extend ::T::Sig
end

class OpenSSL::PKCS12
  extend ::T::Sig
end

module OpenSSL::PKCS5
  extend ::T::Sig
end

class OpenSSL::PKCS7
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS7::PKCS7Error
  extend ::T::Sig
end

class OpenSSL::PKCS7::RecipientInfo
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS7::RecipientInfo
  extend ::T::Sig
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKCS7::SignerInfo
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS7::SignerInfo
  extend ::T::Sig
end

class OpenSSL::PKCS7
  extend ::T::Sig
end

class OpenSSL::PKey::DH
  extend ::T::Sig
end

class OpenSSL::PKey::DHError
  extend ::T::Sig
end

class OpenSSL::PKey::DSA
  extend ::T::Sig
end

class OpenSSL::PKey::DSAError
  extend ::T::Sig
end

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Group
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKey::EC::Group::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Group
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_octet_string(_); end
end

class OpenSSL::PKey::EC::Point::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point
  extend ::T::Sig
end

class OpenSSL::PKey::EC
  extend ::T::Sig
end

class OpenSSL::PKey::ECError
  extend ::T::Sig
end

class OpenSSL::PKey::PKey
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKey::PKey
  extend ::T::Sig
end

class OpenSSL::PKey::PKeyError
  extend ::T::Sig
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

class OpenSSL::PKey::RSA
  extend ::T::Sig
end

class OpenSSL::PKey::RSAError
  extend ::T::Sig
end

module OpenSSL::PKey
  extend ::T::Sig
end

class OpenSSL::Random::RandomError
  extend ::T::Sig
end

module OpenSSL::Random
  extend ::T::Sig
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  extend ::T::Sig
end

class OpenSSL::SSL::SSLError
  extend ::T::Sig
end

class OpenSSL::SSL::SSLErrorWaitReadable
  extend ::T::Sig
end

class OpenSSL::SSL::SSLErrorWaitWritable
  extend ::T::Sig
end

class OpenSSL::SSL::SSLServer
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::SSL::SSLServer
  extend ::T::Sig
end

class OpenSSL::SSL::SSLSocket
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def alpn_protocol(); end

  def tmp_key(); end
end

class OpenSSL::SSL::SSLSocket
  extend ::T::Sig
end

class OpenSSL::SSL::Session
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::SSL::Session::SessionError
  extend ::T::Sig
end

class OpenSSL::SSL::Session
  extend ::T::Sig
end

module OpenSSL::SSL::SocketForwarder
  extend ::T::Sig
end

module OpenSSL::SSL
  extend ::T::Sig
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::T::Sig
end

class OpenSSL::X509::AttributeError
  extend ::T::Sig
end

class OpenSSL::X509::CRL
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::T::Sig
end

class OpenSSL::X509::CRLError
  extend ::T::Sig
end

class OpenSSL::X509::Certificate
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::Certificate
  extend ::T::Sig
end

class OpenSSL::X509::CertificateError
  extend ::T::Sig
end

class OpenSSL::X509::Extension
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::Extension
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionError
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionFactory
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::ExtensionFactory
  extend ::T::Sig
end

class OpenSSL::X509::Name
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_utf8(); end
end

module OpenSSL::X509::Name::RFC2253DN
  extend ::T::Sig
end

class OpenSSL::X509::Name
  extend ::T::Sig
end

class OpenSSL::X509::NameError
  extend ::T::Sig
end

class OpenSSL::X509::Request
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::T::Sig
end

class OpenSSL::X509::RequestError
  extend ::T::Sig
end

class OpenSSL::X509::Revoked
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def to_der(); end
end

class OpenSSL::X509::Revoked
  extend ::T::Sig
end

class OpenSSL::X509::RevokedError
  extend ::T::Sig
end

class OpenSSL::X509::Store
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::Store
  extend ::T::Sig
end

class OpenSSL::X509::StoreContext
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::StoreContext
  extend ::T::Sig
end

class OpenSSL::X509::StoreError
  extend ::T::Sig
end

module OpenSSL::X509
  extend ::T::Sig
end

module OpenSSL
  extend ::T::Sig
  def self.fips_mode(); end
end

class OpenStruct
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenStruct
  extend ::T::Sig
end

OptParse = OptionParser

class OptionParser
  def abort(mesg=T.unsafe(nil)); end

  def accept(*args, &blk); end

  def add_officious(); end

  def banner(); end

  def banner=(banner); end

  def base(); end

  def candidate(word); end

  def compsys(to, name=T.unsafe(nil)); end

  def def_head_option(*opts, &block); end

  def def_option(*opts, &block); end

  def def_tail_option(*opts, &block); end

  def default_argv(); end

  def default_argv=(default_argv); end

  def define(*opts, &block); end

  def define_head(*opts, &block); end

  def define_tail(*opts, &block); end

  def environment(env=T.unsafe(nil)); end

  def getopts(*args); end

  def help(); end

  def inc(*args); end

  def initialize(banner=T.unsafe(nil), width=T.unsafe(nil), indent=T.unsafe(nil)); end

  def load(filename=T.unsafe(nil)); end

  def make_switch(opts, block=T.unsafe(nil)); end

  def new(); end

  def on(*opts, &block); end

  def on_head(*opts, &block); end

  def on_tail(*opts, &block); end

  def order(*argv, into: T.unsafe(nil), &nonopt); end

  def order!(argv=T.unsafe(nil), into: T.unsafe(nil), &nonopt); end

  def parse(*argv, into: T.unsafe(nil)); end

  def parse!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def permute(*argv, into: T.unsafe(nil)); end

  def permute!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def program_name(); end

  def program_name=(program_name); end

  def reject(*args, &blk); end

  def release(); end

  def release=(release); end

  def remove(); end

  def separator(string); end

  def set_banner(_); end

  def set_program_name(_); end

  def set_summary_indent(_); end

  def set_summary_width(_); end

  def summarize(to=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil), &blk); end

  def summary_indent(); end

  def summary_indent=(summary_indent); end

  def summary_width(); end

  def summary_width=(summary_width); end

  def terminate(arg=T.unsafe(nil)); end

  def to_a(); end

  def top(); end

  def ver(); end

  def version(); end

  def version=(version); end

  def warn(mesg=T.unsafe(nil)); end
  ArgumentStyle = ::T.let(nil, ::T.untyped)
  COMPSYS_HEADER = ::T.let(nil, ::T.untyped)
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  DefaultList = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
  NoArgument = ::T.let(nil, ::T.untyped)
  OPTIONAL_ARGUMENT = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
  Officious = ::T.let(nil, ::T.untyped)
  OptionalArgument = ::T.let(nil, ::T.untyped)
  REQUIRED_ARGUMENT = ::T.let(nil, ::T.untyped)
  RequiredArgument = ::T.let(nil, ::T.untyped)
  SPLAT_PROC = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  extend ::T::Sig
end

class OptionParser::AmbiguousArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousArgument
end

class OptionParser::AmbiguousOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousOption
end

module OptionParser::Arguable
  def getopts(*args); end

  def initialize(*args); end

  def options(); end

  def options=(opt); end

  def order!(&blk); end

  def parse!(); end

  def permute!(); end
end

module OptionParser::Arguable
  extend ::T::Sig
  def self.extend_object(obj); end
end

class OptionParser::CompletingHash
  include ::OptionParser::Completion
  def match(key); end
end

class OptionParser::CompletingHash
end

module OptionParser::Completion
  def candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def complete(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def convert(opt=T.unsafe(nil), val=T.unsafe(nil), *_); end
end

module OptionParser::Completion
  extend ::T::Sig
  def self.candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil), &block); end

  def self.regexp(key, icase); end
end

class OptionParser::InvalidArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidArgument
end

class OptionParser::InvalidOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidOption
end

class OptionParser::List
  def accept(t, pat=T.unsafe(nil), &block); end

  def add_banner(to); end

  def append(*args); end

  def atype(); end

  def complete(id, opt, icase=T.unsafe(nil), *pat, &block); end

  def compsys(*args, &block); end

  def each_option(&block); end

  def list(); end

  def long(); end

  def prepend(*args); end

  def reject(t); end

  def search(id, key); end

  def short(); end

  def summarize(*args, &block); end
end

class OptionParser::List
end

class OptionParser::MissingArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::MissingArgument
end

class OptionParser::NeedlessArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::NeedlessArgument
end

class OptionParser::OptionMap
  include ::OptionParser::Completion
end

class OptionParser::OptionMap
end

class OptionParser::ParseError
  def args(); end

  def initialize(*args); end

  def reason(); end

  def reason=(reason); end

  def recover(argv); end

  def set_backtrace(array); end

  def set_option(opt, eq); end
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::ParseError
  def self.filter_backtrace(array); end
end

class OptionParser::Switch
  def add_banner(to); end

  def arg(); end

  def block(); end

  def compsys(sdone, ldone); end

  def conv(); end

  def desc(); end

  def initialize(pattern=T.unsafe(nil), conv=T.unsafe(nil), short=T.unsafe(nil), long=T.unsafe(nil), arg=T.unsafe(nil), desc=T.unsafe(nil), block=T.unsafe(nil), &_block); end

  def long(); end

  def match_nonswitch?(str); end

  def pattern(); end

  def short(); end

  def summarize(sdone=T.unsafe(nil), ldone=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil)); end

  def switch_name(); end
end

class OptionParser::Switch::NoArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::NoArgument
  def self.incompatible_argument_styles(*_); end
end

class OptionParser::Switch::OptionalArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::OptionalArgument
end

class OptionParser::Switch::PlacedArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument
end

class OptionParser::Switch::RequiredArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::RequiredArgument
end

class OptionParser::Switch
  def self.guess(arg); end

  def self.incompatible_argument_styles(arg, t); end

  def self.pattern(); end
end

class OptionParser
  def self.accept(*args, &blk); end

  def self.getopts(*args); end

  def self.inc(arg, default=T.unsafe(nil)); end

  def self.reject(*args, &blk); end

  def self.terminate(arg=T.unsafe(nil)); end

  def self.top(); end

  def self.with(*args, &block); end
end

module Overcommit
  BUG_REPORT_URL = ::T.let(nil, ::T.untyped)
  CONFIG_FILE_NAME = ::T.let(nil, ::T.untyped)
  GIT_VERSION = ::T.let(nil, ::T.untyped)
  HOME = ::T.let(nil, ::T.untyped)
  HOOK_DIRECTORY = ::T.let(nil, ::T.untyped)
  REPO_URL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Overcommit::ConfigurationLoader
  DEFAULT_CONFIG_PATH = ::T.let(nil, ::T.untyped)
end

module Overcommit::Exceptions
  extend ::T::Sig
end

module Overcommit::GitConfig
  extend ::T::Sig
end

module Overcommit::GitRepo
  DIFF_HUNK_REGEX = ::T.let(nil, ::T.untyped)
  SUBMODULE_STATUS_REGEX = ::T.let(nil, ::T.untyped)
end

module Overcommit::GitRepo
  extend ::T::Sig
end

module Overcommit::Hook
  MESSAGE_TYPES = ::T.let(nil, ::T.untyped)
end

module Overcommit::Hook
  extend ::T::Sig
end

module Overcommit::HookContext
  extend ::T::Sig
end

module Overcommit::HookLoader
  extend ::T::Sig
end

class Overcommit::HookSigner
  IGNORED_CONFIG_KEYS = ::T.let(nil, ::T.untyped)
end

class Overcommit::Installer
  MASTER_HOOK = ::T.let(nil, ::T.untyped)
  TEMPLATE_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Overcommit::MessageProcessor
  ERRORS_GENERIC_HEADER = ::T.let(nil, ::T.untyped)
  ERRORS_MODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  ERRORS_UNMODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_GENERIC_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_MODIFIED_HEADER = ::T.let(nil, ::T.untyped)
  WARNINGS_UNMODIFIED_HEADER = ::T.let(nil, ::T.untyped)
end

module Overcommit::OS
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Overcommit::OS
  extend ::T::Sig
end

module Overcommit::Utils::FileUtils
  extend ::T::Sig
end

module Overcommit::Utils
  extend ::T::Sig
end

module Overcommit
  extend ::T::Sig
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapForQueries
  DEFAULT_ARRAY_TYPE_MAP = ::T.let(nil, ::T.untyped)
  DEFAULT_TYPE_MAP = ::T.let(nil, ::T.untyped)
end

module PG::BasicTypeRegistry
  CODERS_BY_NAME = ::T.let(nil, ::T.untyped)
  ValidDirections = ::T.let(nil, ::T.untyped)
  ValidFormats = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
  DONT_QUOTE_TYPES = ::T.let(nil, ::T.untyped)
end

module PG::BasicTypeRegistry
  extend ::T::Sig
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Boolean
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Float
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::ToBase64
end

module PG::BinaryDecoder
  extend ::T::Sig
end

module PG::BinaryEncoder
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
end

module PG::BinaryEncoder
  extend ::T::Sig
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  Params = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  extend ::T::Sig
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
  CONNECT_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
  REDIRECT_METHODS = ::T.let(nil, ::T.untyped)
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

module PG::Constants
  extend ::T::Sig
end

class PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyDecoder
end

class PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

class PG::TextDecoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Array
end

class PG::TextDecoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
end

class PG::TextDecoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
end

class PG::TextDecoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
end

class PG::TextDecoder::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Float
end

class PG::TextDecoder::FromBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
end

class PG::TextDecoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
end

class PG::TextDecoder::Inet
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
end

class PG::TextDecoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Integer
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Numeric
end

class PG::TextDecoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
end

class PG::TextDecoder::Timestamp
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
end

class PG::TextDecoder::TimestampLocal
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtcToLocal
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

module PG::TextDecoder
  extend ::T::Sig
end

class PG::TextEncoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Array
end

class PG::TextEncoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
end

class PG::TextEncoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
end

class PG::TextEncoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
end

class PG::TextEncoder::Date
  STRFTIME_ISO_DATE = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Float
end

class PG::TextEncoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Integer
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
end

class PG::TextEncoder::QuotedLiteral
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::QuotedLiteral
end

class PG::TextEncoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
end

class PG::TextEncoder::TimestampUtc
  STRFTIME_ISO_DATETIME_WITHOUT_TIMEZONE_UTC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampWithTimeZone
  STRFTIME_ISO_DATETIME_WITH_TIMEZONE = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampWithoutTimeZone
  STRFTIME_ISO_DATETIME_WITHOUT_TIMEZONE = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::ToBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::ToBase64
end

module PG::TextEncoder
  extend ::T::Sig
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
end

module PG::TypeMap::DefaultTypeMappable
  extend ::T::Sig
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

module PG
  extend ::T::Sig
end

module PP::ObjectMixin
  extend ::T::Sig
end

module PP::PPMethods
  extend ::T::Sig
end

class PP::SingleLine
  extend ::T::Sig
end

class PP
  extend ::T::Sig
end

ParseError = Racc::ParseError

class Pathname
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end

end

class Pathname
  extend ::T::Sig
end

class PrettyPrint
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Breakable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Breakable
  extend ::T::Sig
end

class PrettyPrint::Group
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Group
  extend ::T::Sig
end

class PrettyPrint::GroupQueue
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::GroupQueue
  extend ::T::Sig
end

class PrettyPrint::SingleLine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::SingleLine
  extend ::T::Sig
end

class PrettyPrint::Text
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Text
  extend ::T::Sig
end

class PrettyPrint
  extend ::T::Sig
end

class Proc
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def [](*_); end

  def clone(); end

  def lambda?(); end

  def yield(*_); end
end

class Proc
  extend ::T::Sig
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::GID
  extend ::T::Sig
end

class Process::Status
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Process::Status
  extend ::T::Sig
end

module Process::Sys
  extend ::T::Sig
  def self.getegid(); end

end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  extend ::T::Sig
  def self.[](*_); end

  def self.members(); end
end

module Process::UID
  extend ::T::Sig
end

class Process::Waiter
  extend ::T::Sig
end

module Process
  extend ::T::Sig
  def self.last_status(); end

  def self.setpgrp(); end

end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
  extend ::T::Sig
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
  extend ::T::Sig
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
  extend ::T::Sig
end

module Psych::JSON
  extend ::T::Sig
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
  extend ::T::Sig
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
  extend ::T::Sig
end

module Psych::Streaming
  extend ::T::Sig
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
  extend ::T::Sig
end

module Psych
  extend ::T::Sig
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

Queue = Thread::Queue

module RDoc
  ATTR_MODIFIERS = ::T.let(nil, ::T.untyped)
  CLASS_MODIFIERS = ::T.let(nil, ::T.untyped)
  CONSTANT_MODIFIERS = ::T.let(nil, ::T.untyped)
  DOT_DOC_FILENAME = ::T.let(nil, ::T.untyped)
  GENERAL_MODIFIERS = ::T.let(nil, ::T.untyped)
  KNOWN_CLASSES = ::T.let(nil, ::T.untyped)
  METHOD_MODIFIERS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VISIBILITIES = ::T.let(nil, ::T.untyped)
end

class RDoc::Alias
  def aref(); end

  def full_old_name(); end

  def html_name(); end

  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end

  def name(); end

  def name_prefix(); end

  def new_name(); end

  def old_name(); end

  def pretty_name(); end

  def pretty_new_name(); end

  def pretty_old_name(); end

  def singleton(); end

  def singleton=(singleton); end

  def text(); end
end

class RDoc::Alias
end

class RDoc::AnonClass
end

class RDoc::AnonClass
end

class RDoc::AnyMethod
  include ::RDoc::TokenStream
  def add_alias(an_alias, context=T.unsafe(nil)); end

  def c_function(); end

  def c_function=(c_function); end

  def call_seq=(call_seq); end

  def calls_super(); end

  def calls_super=(calls_super); end

  def dont_rename_initialize(); end

  def dont_rename_initialize=(dont_rename_initialize); end

  def marshal_dump(); end

  def marshal_load(array); end

  def param_list(); end

  def superclass_method(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::AnyMethod
end

class RDoc::Attr
  def calls_super(); end

  def definition(); end

  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(array); end

  def rw(); end

  def rw=(rw); end

  def token_stream(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Attr
end

class RDoc::ClassModule
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Comment
  include ::RDoc::Text
  def ==(other); end

  def document=(document); end

  def empty?(); end

  def encode!(encoding); end

  def extract_call_seq(method); end

  def file(); end

  def format(); end

  def format=(format); end

  def initialize(text=T.unsafe(nil), location=T.unsafe(nil)); end

  def location(); end

  def location=(location); end

  def normalize(); end

  def normalized?(); end

  def parse(); end

  def remove_private(); end

  def text(); end

  def text=(text); end

  def tomdoc?(); end
end

class RDoc::Comment
end

class RDoc::Constant
  def ==(other); end

  def full_name(); end

  def initialize(name, value, comment); end

  def is_alias_for(); end

  def is_alias_for=(is_alias_for); end

  def marshal_dump(); end

  def marshal_load(array); end

  def name(); end

  def name=(name); end

  def path(); end

  def value(); end

  def value=(value); end

  def visibility(); end

  def visibility=(visibility); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Constant
end

class RDoc::Context
  TOMDOC_TITLES = ::T.let(nil, ::T.untyped)
  TOMDOC_TITLES_SORT = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class RDoc::Context::Section
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::CrossReference
  def initialize(context); end

  def resolve(name, text); end

  def seen(); end

  def seen=(seen); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::CrossReference
end

class RDoc::ERBIO
  def initialize(str, safe_level=T.unsafe(nil), trim_mode=T.unsafe(nil), eoutvar=T.unsafe(nil)); end

  def set_eoutvar(compiler, io_variable); end
end

class RDoc::ERBIO
end

class RDoc::ERBPartial
end

class RDoc::ERBPartial
end

module RDoc::Encoding
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

module RDoc::Encoding
  extend ::T::Sig
  def self.change_encoding(text, encoding); end

  def self.detect_encoding(string); end

  def self.read_file(filename, encoding, force_transcode=T.unsafe(nil)); end

  def self.remove_frozen_string_literal(string); end

  def self.remove_magic_comment(string); end
end

class RDoc::Extend
end

class RDoc::Extend
end

class RDoc::Generator::Darkfish
  BUILTIN_STYLE_ITEMS = ::T.let(nil, ::T.untyped)
  DESCRIPTION = ::T.let(nil, ::T.untyped)
  GENERATOR_DIR = ::T.let(nil, ::T.untyped)
  SVNID_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::JsonIndex
  include ::RDoc::Text
  def build_index(); end

  def class_dir(); end

  def debug_msg(*msg); end

  def file_dir(); end

  def generate(); end

  def generate_gzipped(); end

  def index(); end

  def index_classes(); end

  def index_methods(); end

  def index_pages(); end

  def initialize(parent_generator, options); end

  def reset(files, classes); end

  def search_string(string); end
  SEARCH_INDEX_FILE = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::JsonIndex
end

module RDoc::Generator::Markup
  extend ::T::Sig
end

class RDoc::Generator::POT
  DESCRIPTION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::RI
  DESCRIPTION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::SDoc
  CLASS_DIR = ::T.let(nil, ::T.untyped)
  DESCRIPTION = ::T.let(nil, ::T.untyped)
  FILE_DIR = ::T.let(nil, ::T.untyped)
  GENERATOR_DIRS = ::T.let(nil, ::T.untyped)
  RESOURCES_DIR = ::T.let(nil, ::T.untyped)
  SEARCH_INDEX_FILE = ::T.let(nil, ::T.untyped)
  TREE_FILE = ::T.let(nil, ::T.untyped)
end

module RDoc::Generator
  extend ::T::Sig
end

class RDoc::GhostMethod
end

class RDoc::GhostMethod
end

class RDoc::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class RDoc::I18n::Locale
  def self.[](locale_name); end

  def self.[]=(locale_name, locale); end
end

module RDoc::I18n
  extend ::T::Sig
end

class RDoc::Include
end

class RDoc::Include
end

class RDoc::Markdown
  DEFAULT_EXTENSIONS = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HTML_ENTITIES = ::T.let(nil, ::T.untyped)
  Rules = ::T.let(nil, ::T.untyped)
end

class RDoc::Markdown::Literals
  Rules = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::AttrChanger
  def turn_off(); end

  def turn_off=(_); end

  def turn_on(); end

  def turn_on=(_); end
end

class RDoc::Markup::AttrChanger
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Markup::AttrSpan
  def [](n); end

  def initialize(length); end

  def set_attrs(start, length, bits); end
end

class RDoc::Markup::AttrSpan
end

class RDoc::Markup::AttributeManager
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute(turn_on, turn_off); end

  def attributes(); end

  def change_attribute(current, new); end

  def changed_attribute_by_name(current_set, new_set); end

  def convert_attrs(str, attrs); end

  def convert_html(str, attrs); end

  def convert_regexp_handlings(str, attrs); end

  def copy_string(start_pos, end_pos); end

  def display_attributes(); end

  def flow(str); end

  def html_tags(); end

  def mask_protected_sequences(); end

  def matching_word_pairs(); end

  def protectable(); end

  def regexp_handlings(); end

  def split_into_flow(); end

  def unmask_protected_sequences(); end

  def word_pair_map(); end
  A_PROTECT = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PROTECT_ATTR = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::AttributeManager
end

class RDoc::Markup::Attributes
  def as_string(bitmap); end

  def bitmap_for(name); end

  def each_name_of(bitmap); end

  def regexp_handling(); end
end

class RDoc::Markup::Attributes
end

class RDoc::Markup::BlankLine
  def accept(visitor); end
end

class RDoc::Markup::BlankLine
  def self.new(); end
end

class RDoc::Markup::BlockQuote
end

class RDoc::Markup::BlockQuote
end

class RDoc::Markup::Document
  include ::Enumerable
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def concat(parts); end

  def each(&block); end

  def empty?(); end

  def file(); end

  def file=(location); end

  def initialize(*parts); end

  def merge(other); end

  def merged?(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def parts(); end

  def push(*parts); end

  def table_of_contents(); end
end

class RDoc::Markup::Document
end

class RDoc::Markup::HardBreak
  def ==(other); end

  def accept(visitor); end
end

class RDoc::Markup::HardBreak
  def self.new(); end
end

class RDoc::Markup::Heading
  def accept(visitor); end

  def aref(); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def level=(_); end

  def plain_html(); end

  def text(); end

  def text=(_); end
end

class RDoc::Markup::Heading
  def self.[](*_); end

  def self.members(); end

  def self.to_html(); end

  def self.to_label(); end
end

class RDoc::Markup::Include
  def ==(other); end

  def file(); end

  def include_path(); end

  def initialize(file, include_path); end
end

class RDoc::Markup::Include
end

class RDoc::Markup::IndentedParagraph
  def indent(); end

  def initialize(indent, *parts); end

  def text(hard_break=T.unsafe(nil)); end
end

class RDoc::Markup::IndentedParagraph
end

class RDoc::Markup::List
  def <<(item); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(type=T.unsafe(nil), *items); end

  def items(); end

  def last(); end

  def push(*items); end

  def type(); end

  def type=(type); end
end

class RDoc::Markup::List
end

class RDoc::Markup::ListItem
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(label=T.unsafe(nil), *parts); end

  def label(); end

  def label=(label); end

  def length(); end

  def parts(); end

  def push(*parts); end
end

class RDoc::Markup::ListItem
end

class RDoc::Markup::Paragraph
  def text(hard_break=T.unsafe(nil)); end
end

class RDoc::Markup::Paragraph
end

class RDoc::Markup::Parser
  LIST_TOKENS = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::Raw
  def <<(text); end

  def ==(other); end

  def accept(visitor); end

  def initialize(*parts); end

  def merge(other); end

  def parts(); end

  def push(*texts); end

  def text(); end
end

class RDoc::Markup::Raw
end

class RDoc::Markup::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::RegexpHandling
end

class RDoc::Markup::Rule
  def accept(visitor); end
end

class RDoc::Markup::Rule
end

class RDoc::Markup::ToAnsi
end

class RDoc::Markup::ToAnsi
end

class RDoc::Markup::ToBs
end

class RDoc::Markup::ToBs
end

class RDoc::Markup::ToHtml
  include ::RDoc::Text
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def code_object(); end

  def code_object=(code_object); end

  def convert_string(text); end

  def end_accepting(); end

  def from_path(); end

  def from_path=(from_path); end

  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def html_list_name(list_type, open_tag); end

  def in_list_entry(); end

  def init_tags(); end

  def list(); end

  def list_end_for(list_type); end

  def list_item_start(list_item, list_type); end

  def parseable?(text); end

  def res(); end

  def start_accepting(); end

  def to_html(item); end
  LIST_TYPE_TO_HTML = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::ToHtml
end

class RDoc::Markup::ToHtmlCrossref
  def context(); end

  def context=(context); end

  def cross_reference(name, text=T.unsafe(nil), code=T.unsafe(nil)); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end

  def link(name, text, code=T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::ToHtmlCrossref
end

class RDoc::Markup::ToHtmlSnippet
  def accept_raw(*node); end

  def accept_rule(*node); end

  def add_paragraph(); end

  def character_limit(); end

  def characters(); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end

  def mask(); end

  def paragraph_limit(); end

  def paragraphs(); end

  def truncate(text); end
end

class RDoc::Markup::ToHtmlSnippet
end

class RDoc::Markup::ToLabel
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def convert(text); end

  def end_accepting(*node); end

  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end

  def res(); end

  def start_accepting(*node); end
end

class RDoc::Markup::ToLabel
end

class RDoc::Markup::ToMarkdown
  def gen_url(url, text); end

  def handle_rdoc_link(url); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToMarkdown
end

class RDoc::Markup::ToRdoc
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_indented_paragraph(paragraph); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def attributes(text); end

  def end_accepting(); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def indent(); end

  def indent=(indent); end

  def init_tags(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_index(); end

  def list_type(); end

  def list_width(); end

  def prefix(); end

  def res(); end

  def start_accepting(); end

  def use_prefix(); end

  def width(); end

  def width=(width); end

  def wrap(text); end
end

class RDoc::Markup::ToRdoc
end

class RDoc::Markup::ToTableOfContents
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(heading); end

  def accept_list_end(*node); end

  def accept_list_end_bullet(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def res(); end

  def start_accepting(); end

  def suppressed?(heading); end
end

class RDoc::Markup::ToTableOfContents
  def self.to_toc(); end
end

class RDoc::Markup::ToTest
  def accept_blank_line(blank_line); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def end_accepting(); end

  def start_accepting(); end
end

class RDoc::Markup::ToTest
end

class RDoc::Markup::ToTtOnly
  def accept_blank_line(markup_item); end

  def accept_block_quote(block_quote); end

  def accept_heading(markup_item); end

  def accept_list_end(list); end

  def accept_list_item_end(markup_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(markup_item); end

  def accept_rule(markup_item); end

  def accept_verbatim(markup_item); end

  def do_nothing(markup_item); end

  def end_accepting(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_type(); end

  def res(); end

  def start_accepting(); end

  def tt_sections(text); end
end

class RDoc::Markup::ToTtOnly
end

class RDoc::Markup::Verbatim
  def format(); end

  def format=(format); end

  def normalize(); end

  def ruby?(); end
end

class RDoc::Markup::Verbatim
end

class RDoc::MetaMethod
end

class RDoc::MetaMethod
end

class RDoc::Mixin
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, comment); end

  def module(); end

  def name(); end

  def name=(name); end
end

class RDoc::Mixin
end

class RDoc::NormalClass
  def definition(); end
end

class RDoc::NormalClass
end

class RDoc::NormalModule
  def definition(); end
end

class RDoc::NormalModule
end

class RDoc::Options
  DEPRECATED = ::T.let(nil, ::T.untyped)
  Directory = ::T.let(nil, ::T.untyped)
  Path = ::T.let(nil, ::T.untyped)
  PathArray = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  Template = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser
  def file_name(); end

  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  include ::RDoc::Text
  def classes(); end

  def content(); end

  def content=(content); end

  def deduplicate_call_seq(); end

  def deduplicate_method_name(class_obj, method_name); end

  def do_aliases(); end

  def do_attrs(); end

  def do_boot_defclass(); end

  def do_classes(); end

  def do_constants(); end

  def do_define_class(); end

  def do_define_class_under(); end

  def do_define_module(); end

  def do_define_module_under(); end

  def do_includes(); end

  def do_methods(); end

  def do_missing(); end

  def do_modules(); end

  def do_singleton_class(); end

  def do_struct_define_without_accessor(); end

  def enclosure_dependencies(); end

  def find_alias_comment(class_name, new_name, old_name); end

  def find_attr_comment(var_name, attr_name, read=T.unsafe(nil), write=T.unsafe(nil)); end

  def find_body(class_name, meth_name, meth_obj, file_content, quiet=T.unsafe(nil)); end

  def find_class(raw_name, name); end

  def find_class_comment(class_name, class_mod); end

  def find_const_comment(type, const_name, class_name=T.unsafe(nil)); end

  def find_modifiers(comment, meth_obj); end

  def find_override_comment(class_name, meth_obj); end

  def gen_body_table(file_content); end

  def gen_const_table(file_content); end

  def handle_attr(var_name, attr_name, read, write); end

  def handle_class_module(var_name, type, class_name, parent, in_module); end

  def handle_constants(type, var_name, const_name, definition); end

  def handle_ifdefs_in(body); end

  def handle_method(type, var_name, meth_name, function, param_count, source_file=T.unsafe(nil)); end

  def handle_singleton(sclass_var, class_var); end

  def handle_tab_width(body); end

  def known_classes(); end

  def load_variable_map(map_name); end

  def look_for_directives_in(context, comment); end

  def missing_dependencies(); end

  def rb_scan_args(method_body); end

  def remove_commented_out_lines(); end

  def scan(); end

  def singleton_classes(); end

  def top_level(); end
end

class RDoc::Parser::C
end

class RDoc::Parser::ChangeLog
  include ::RDoc::Parser::Text
  def continue_entry_body(entry_body, continuation); end

  def create_document(groups); end

  def create_entries(entries); end

  def create_items(items); end

  def group_entries(entries); end

  def parse_entries(); end

  def scan(); end
end

class RDoc::Parser::ChangeLog
end

class RDoc::Parser::Markdown
  include ::RDoc::Parser::Text
  def scan(); end
end

class RDoc::Parser::Markdown
end

class RDoc::Parser::RD
  include ::RDoc::Parser::Text
  def scan(); end
end

class RDoc::Parser::RD
end

class RDoc::Parser::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::RipperStateLex::InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def char_no(); end

  def char_no=(_); end

  def kind(); end

  def kind=(_); end

  def line_no(); end

  def line_no=(_); end

  def state(); end

  def state=(_); end

  def text(); end

  def text=(_); end
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Parser::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Parser::Ruby
  include ::RDoc::TokenStream
  include ::RDoc::Parser::RubyTools
  def collect_first_comment(); end

  def consume_trailing_spaces(); end

  def create_attr(container, single, name, rw, comment); end

  def create_module_alias(container, constant, rhs_name); end

  def error(msg); end

  def get_bool(); end

  def get_class_or_module(container, ignore_constants=T.unsafe(nil)); end

  def get_class_specification(); end

  def get_constant(); end

  def get_end_token(tk); end

  def get_included_module_with_optional_parens(); end

  def get_method_container(container, name_t); end

  def get_symbol_or_name(); end

  def get_tkread_clean(pattern, replacement); end

  def get_visibility_information(tk, single); end

  def look_for_directives_in(container, comment); end

  def make_message(message); end

  def new_comment(comment); end

  def parse_alias(context, single, tk, comment); end

  def parse_attr(context, single, tk, comment); end

  def parse_attr_accessor(context, single, tk, comment); end

  def parse_call_parameters(tk); end

  def parse_class(container, single, tk, comment); end

  def parse_class_regular(container, declaration_context, single, name_t, given_name, comment); end

  def parse_class_singleton(container, name, comment); end

  def parse_comment(container, tk, comment); end

  def parse_comment_attr(container, type, name, comment); end

  def parse_comment_ghost(container, text, name, column, line_no, comment); end

  def parse_comment_tomdoc(container, tk, comment); end

  def parse_constant(container, tk, comment, ignore_constants=T.unsafe(nil)); end

  def parse_constant_body(container, constant, is_array_or_hash); end

  def parse_constant_visibility(container, single, tk); end

  def parse_extend_or_include(klass, container, comment); end

  def parse_identifier(container, single, tk, comment); end

  def parse_meta_attr(context, single, tk, comment); end

  def parse_meta_method(container, single, tk, comment); end

  def parse_meta_method_name(comment, tk); end

  def parse_meta_method_params(container, single, meth, tk, comment); end

  def parse_method(container, single, tk, comment); end

  def parse_method_dummy(container); end

  def parse_method_name(container); end

  def parse_method_name_regular(container, name_t); end

  def parse_method_name_singleton(container, name_t); end

  def parse_method_or_yield_parameters(method=T.unsafe(nil), modifiers=T.unsafe(nil)); end

  def parse_method_parameters(method); end

  def parse_method_params_and_body(container, single, meth, added_container); end

  def parse_module(container, single, tk, comment); end

  def parse_require(context, comment); end

  def parse_rescue(); end

  def parse_statements(container, single=T.unsafe(nil), current_method=T.unsafe(nil), comment=T.unsafe(nil)); end

  def parse_symbol_arg(no=T.unsafe(nil)); end

  def parse_symbol_arg_paren(no); end

  def parse_symbol_arg_space(no, tk); end

  def parse_symbol_in_arg(); end

  def parse_top_level_statements(container); end

  def parse_visibility(container, single, tk); end

  def parse_yield(context, single, tk, method); end

  def read_directive(allowed); end

  def read_documentation_modifiers(context, allowed); end

  def record_location(container); end

  def retrieve_comment_body(tk); end

  def scan(); end

  def skip_for_variable(); end

  def skip_method(container); end

  def skip_optional_do_after_expression(); end

  def skip_tkspace_comment(skip_nl=T.unsafe(nil)); end

  def suppress_parents(container, ancestor); end

  def tk_nl?(tk); end

  def update_visibility(container, vis_type, vis, singleton); end

  def warn(message); end
  NORMAL = ::T.let(nil, ::T.untyped)
  SINGLE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::Ruby
end

module RDoc::Parser::RubyTools
  def add_token_listener(obj); end

  def get_tk(); end

  def get_tk_until(*tokens); end

  def get_tkread(); end

  def peek_read(); end

  def peek_tk(); end

  def remove_token_listener(obj); end

  def reset(); end

  def skip_tkspace(); end

  def skip_tkspace_without_nl(); end

  def token_listener(obj); end

  def unget_tk(tk); end
end

module RDoc::Parser::RubyTools
  extend ::T::Sig
end

class RDoc::Parser::Simple
  include ::RDoc::Parser::Text
  def content(); end

  def remove_coding_comment(text); end

  def remove_private_comment(comment); end

  def scan(); end
end

class RDoc::Parser::Simple
end

module RDoc::Parser::Text
end

module RDoc::Parser::Text
  extend ::T::Sig
end

class RDoc::Parser
  def self.alias_extension(old_ext, new_ext); end

  def self.binary?(file); end

  def self.can_parse(file_name); end

  def self.can_parse_by_name(file_name); end

  def self.check_modeline(file_name); end

  def self.for(top_level, file_name, content, options, stats); end

  def self.parse_files_matching(regexp); end

  def self.parsers(); end

  def self.remove_modeline(content); end

  def self.use_markup(content); end

  def self.zip?(file); end
end

class RDoc::RD::BlockParser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def add_footnote(content); end

  def add_label(label); end

  def content(values); end

  def footnotes(); end

  def include_path(); end

  def include_path=(include_path); end

  def labels(); end

  def line_index(); end

  def on_error(et, ev, _values); end

  def paragraph(value); end

  def parse(src); end
  MARK_TO_LEVEL = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
  TMPFILE = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::BlockParser
end

class RDoc::RD::Inline
  def ==(other); end

  def append(more); end

  def initialize(rdoc, reference); end

  def rdoc(); end

  def reference(); end
end

class RDoc::RD::Inline
  def self.new(rdoc, reference=T.unsafe(nil)); end
end

class RDoc::RD::InlineParser
  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(block_parser); end

  def inline(rdoc, reference=T.unsafe(nil)); end

  def next_words_on_error(); end

  def on_error(et, ev, values); end

  def parse(inline); end

  def prev_words_on_error(ev); end
  BACK_SLASH = ::T.let(nil, ::T.untyped)
  BACK_SLASH_RE = ::T.let(nil, ::T.untyped)
  BAR = ::T.let(nil, ::T.untyped)
  BAR_RE = ::T.let(nil, ::T.untyped)
  CODE_CLOSE = ::T.let(nil, ::T.untyped)
  CODE_CLOSE_RE = ::T.let(nil, ::T.untyped)
  CODE_OPEN = ::T.let(nil, ::T.untyped)
  CODE_OPEN_RE = ::T.let(nil, ::T.untyped)
  EM_CLOSE = ::T.let(nil, ::T.untyped)
  EM_CLOSE_RE = ::T.let(nil, ::T.untyped)
  EM_OPEN = ::T.let(nil, ::T.untyped)
  EM_OPEN_RE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_CLOSE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_CLOSE_RE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_OPEN = ::T.let(nil, ::T.untyped)
  FOOTNOTE_OPEN_RE = ::T.let(nil, ::T.untyped)
  INDEX_CLOSE = ::T.let(nil, ::T.untyped)
  INDEX_CLOSE_RE = ::T.let(nil, ::T.untyped)
  INDEX_OPEN = ::T.let(nil, ::T.untyped)
  INDEX_OPEN_RE = ::T.let(nil, ::T.untyped)
  KBD_CLOSE = ::T.let(nil, ::T.untyped)
  KBD_CLOSE_RE = ::T.let(nil, ::T.untyped)
  KBD_OPEN = ::T.let(nil, ::T.untyped)
  KBD_OPEN_RE = ::T.let(nil, ::T.untyped)
  OTHER_RE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  QUOTE_RE = ::T.let(nil, ::T.untyped)
  REF_CLOSE = ::T.let(nil, ::T.untyped)
  REF_CLOSE_RE = ::T.let(nil, ::T.untyped)
  REF_OPEN = ::T.let(nil, ::T.untyped)
  REF_OPEN_RE = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  SLASH_RE = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  URL_RE = ::T.let(nil, ::T.untyped)
  VAR_CLOSE = ::T.let(nil, ::T.untyped)
  VAR_CLOSE_RE = ::T.let(nil, ::T.untyped)
  VAR_OPEN = ::T.let(nil, ::T.untyped)
  VAR_OPEN_RE = ::T.let(nil, ::T.untyped)
  VERB_CLOSE = ::T.let(nil, ::T.untyped)
  VERB_CLOSE_RE = ::T.let(nil, ::T.untyped)
  VERB_OPEN = ::T.let(nil, ::T.untyped)
  VERB_OPEN_RE = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::InlineParser
end

class RDoc::RDoc
  GENERATORS = ::T.let(nil, ::T.untyped)
end

module RDoc::RI
end

class RDoc::RI::Driver
  def add_also_in(out, also_in); end

  def add_class(out, name, classes); end

  def add_extends(out, extends); end

  def add_extension_modules(out, type, extensions); end

  def add_extension_modules_multiple(out, store, modules); end

  def add_extension_modules_single(out, store, include); end

  def add_from(out, store); end

  def add_includes(out, includes); end

  def add_method(out, name); end

  def add_method_documentation(out, klass); end

  def add_method_list(out, methods, name); end

  def ancestors_of(klass); end

  def check_did_you_mean(); end

  def class_cache(); end

  def class_document(name, found, klasses, includes, extends); end

  def class_document_comment(out, comment); end

  def class_document_constants(out, klass); end

  def classes(); end

  def classes_and_includes_and_extends_for(name); end

  def complete(name); end

  def complete_klass(name, klass, selector, method, completions); end

  def complete_method(name, klass, selector, completions); end

  def display(document); end

  def display_class(name); end

  def display_method(name); end

  def display_name(name); end

  def display_names(names); end

  def display_page(name); end

  def display_page_list(store, pages=T.unsafe(nil), search=T.unsafe(nil)); end

  def expand_class(klass); end

  def expand_name(name); end

  def filter_methods(found, name); end

  def find_methods(name); end

  def find_pager_jruby(pager); end

  def find_store(name); end

  def formatter(io); end

  def in_path?(file); end

  def initialize(initial_options=T.unsafe(nil)); end

  def interactive(); end

  def list_known_classes(names=T.unsafe(nil)); end

  def list_methods_matching(name); end

  def load_method(store, cache, klass, type, name); end

  def load_methods_matching(name); end

  def lookup_method(name); end

  def method_document(name, filtered); end

  def method_type(selector); end

  def name_regexp(name); end

  def page(); end

  def paging?(); end

  def parse_name(name); end

  def render_class(out, store, klass, also_in); end

  def render_method(out, store, method, name); end

  def render_method_arguments(out, arglists); end

  def render_method_comment(out, method, alias_for=T.unsafe(nil)); end

  def render_method_superclass(out, method); end

  def run(); end

  def setup_pager(); end

  def show_all(); end

  def show_all=(show_all); end

  def start_server(); end

  def stores(); end

  def stores=(stores); end

  def use_stdout(); end

  def use_stdout=(use_stdout); end
end

class RDoc::RI::Driver::Error
end

class RDoc::RI::Driver::Error
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestions=T.unsafe(nil)); end

  def name(); end
end

class RDoc::RI::Driver::NotFoundError
end

class RDoc::RI::Driver
  def self.default_options(); end

  def self.dump(data_path); end

  def self.process_args(argv); end

  def self.run(argv=T.unsafe(nil)); end
end

class RDoc::RI::Error
end

class RDoc::RI::Error
end

module RDoc::RI::Paths
  BASE = ::T.let(nil, ::T.untyped)
  HOMEDIR = ::T.let(nil, ::T.untyped)
end

module RDoc::RI::Paths
  extend ::T::Sig
  def self.each(system=T.unsafe(nil), site=T.unsafe(nil), home=T.unsafe(nil), gems=T.unsafe(nil), *extra_dirs, &blk); end

  def self.gem_dir(name, version); end

  def self.gemdirs(filter=T.unsafe(nil)); end

  def self.home_dir(); end

  def self.path(system=T.unsafe(nil), site=T.unsafe(nil), home=T.unsafe(nil), gems=T.unsafe(nil), *extra_dirs); end

  def self.raw_path(system, site, home, gems, *extra_dirs); end

  def self.site_dir(); end

  def self.system_dir(); end
end

RDoc::RI::Store = RDoc::Store

module RDoc::RI
  extend ::T::Sig
end

class RDoc::Require
  def initialize(name, comment); end

  def name(); end

  def name=(name); end

  def top_level(); end
end

class RDoc::Require
end

class RDoc::Servlet
  def asset(generator_name, req, res); end

  def asset_dirs(); end

  def documentation_page(store, generator, path, req, res); end

  def documentation_search(store, generator, req, res); end

  def documentation_source(path); end

  def error(exception, req, res); end

  def generator_for(store); end

  def if_modified_since(req, res, path=T.unsafe(nil)); end

  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end

  def installed_docs(); end

  def not_found(generator, req, res, message=T.unsafe(nil)); end

  def options(); end

  def ri_paths(&block); end

  def root(req, res); end

  def root_search(req, res); end

  def show_documentation(req, res); end

  def store_for(source_name); end
end

class RDoc::Servlet
end

class RDoc::SingleClass
  def definition(); end
end

class RDoc::SingleClass
end

class RDoc::Stats
  include ::RDoc::Text
  def add_alias(as); end

  def add_attribute(attribute); end

  def add_class(klass); end

  def add_constant(constant); end

  def add_file(file); end

  def add_method(method); end

  def add_module(mod); end

  def begin_adding(); end

  def calculate(); end

  def coverage_level(); end

  def coverage_level=(level); end

  def doc_stats(collection); end

  def done_adding(); end

  def files_so_far(); end

  def fully_documented?(); end

  def great_job(); end

  def initialize(store, num_files, verbosity=T.unsafe(nil)); end

  def num_files(); end

  def percent_doc(); end

  def report(); end

  def report_attributes(cm); end

  def report_class_module(cm); end

  def report_constants(cm); end

  def report_methods(cm); end

  def summary(); end

  def undoc_params(method); end
end

class RDoc::Stats::Normal
  def begin_adding(); end

  def done_adding(); end

  def print_file(files_so_far, filename); end
end

class RDoc::Stats::Normal
end

class RDoc::Stats::Quiet
  def begin_adding(*_); end

  def done_adding(*_); end

  def initialize(num_files); end

  def print_alias(*_); end

  def print_attribute(*_); end

  def print_class(*_); end

  def print_constant(*_); end

  def print_file(*_); end

  def print_method(*_); end

  def print_module(*_); end
end

class RDoc::Stats::Quiet
end

class RDoc::Stats::Verbose
  def nodoc(co); end

  def print_alias(as); end

  def print_attribute(attribute); end

  def print_class(klass); end

  def print_constant(constant); end

  def print_file(files_so_far, file); end

  def print_method(method); end

  def print_module(mod); end
end

class RDoc::Stats::Verbose
end

class RDoc::Stats
end

class RDoc::Store
  def add_c_enclosure(variable, namespace); end

  def add_c_variables(c_parser); end

  def add_file(absolute_name, relative_name: T.unsafe(nil), parser: T.unsafe(nil)); end

  def all_classes(); end

  def all_classes_and_modules(); end

  def all_files(); end

  def all_modules(); end

  def ancestors(); end

  def attributes(); end

  def c_class_variables(); end

  def c_enclosure_classes(); end

  def c_enclosure_names(); end

  def c_singleton_class_variables(); end

  def cache(); end

  def cache_path(); end

  def class_file(klass_name); end

  def class_methods(); end

  def class_path(klass_name); end

  def classes_hash(); end

  def clean_cache_collection(collection); end

  def complete(min_visibility); end

  def dry_run(); end

  def dry_run=(dry_run); end

  def encoding(); end

  def encoding=(encoding); end

  def files_hash(); end

  def find_c_enclosure(variable); end

  def find_class_named(name); end

  def find_class_named_from(name, from); end

  def find_class_or_module(name); end

  def find_file_named(name); end

  def find_module_named(name); end

  def find_text_page(file_name); end

  def find_unique(all_hash); end

  def fix_basic_object_inheritance(); end

  def friendly_path(); end

  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def instance_methods(); end

  def load_all(); end

  def load_cache(); end

  def load_class(klass_name); end

  def load_class_data(klass_name); end

  def load_method(klass_name, method_name); end

  def load_page(page_name); end

  def main(); end

  def main=(page); end

  def make_variable_map(variables); end

  def method_file(klass_name, method_name); end

  def module_names(); end

  def modules_hash(); end

  def page(name); end

  def page_file(page_name); end

  def path(); end

  def path=(path); end

  def rdoc(); end

  def rdoc=(rdoc); end

  def remove_nodoc(all_hash); end

  def save(); end

  def save_cache(); end

  def save_class(klass); end

  def save_method(klass, method); end

  def save_page(page); end

  def source(); end

  def title(); end

  def title=(title); end

  def type(); end

  def type=(type); end

  def unique_classes(); end

  def unique_classes_and_modules(); end

  def unique_modules(); end

  def unmatched_constant_alias(); end

  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::Error
end

class RDoc::Store::Error
end

class RDoc::Store::MissingFileError
  def file(); end

  def initialize(store, file, name); end

  def name(); end

  def store(); end
end

class RDoc::Store::MissingFileError
end

class RDoc::Store
end

class RDoc::Task
  def before_running_rdoc(&block); end

  def check_names(names); end

  def clobber_task_description(); end

  def defaults(); end

  def define(); end

  def external(); end

  def external=(external); end

  def generator(); end

  def generator=(generator); end

  def initialize(name=T.unsafe(nil)); end

  def inline_source(); end

  def inline_source=(value); end

  def main(); end

  def main=(main); end

  def markup(); end

  def markup=(markup); end

  def name(); end

  def name=(name); end

  def option_list(); end

  def options(); end

  def options=(options); end

  def rdoc_dir(); end

  def rdoc_dir=(rdoc_dir); end

  def rdoc_files(); end

  def rdoc_files=(rdoc_files); end

  def rdoc_task_description(); end

  def rerdoc_task_description(); end

  def template(); end

  def template=(template); end

  def title(); end

  def title=(title); end
end

class RDoc::Task
end

module RDoc::Text
  MARKUP_FORMAT = ::T.let(nil, ::T.untyped)
  TO_HTML_CHARACTERS = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  extend ::T::Sig
end

module RDoc::TokenStream
  def add_token(*tokens); end

  def add_tokens(*tokens); end

  def collect_tokens(); end

  def pop_token(); end

  def start_collecting_tokens(); end

  def token_stream(); end

  def tokens_to_s(); end
end

module RDoc::TokenStream
  extend ::T::Sig
  def self.to_html(token_stream); end
end

class RDoc::TopLevel
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

module RDoc
  extend ::T::Sig
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::ParseError
  extend ::T::Sig
end

class Racc::Parser
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Racc::Parser
  extend ::T::Sig
end

module Racc
  extend ::T::Sig
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_ADDR = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
  extend ::T::Sig
end

module Rack::Auth
  extend ::T::Sig
end

class Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked::Body
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def path(); end

  def root(); end

  def stat(node); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::File
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, options=T.unsafe(nil)); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, options=T.unsafe(nil)); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  extend ::T::Sig
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

module Rack::Lint::Assertion
  extend ::T::Sig
end

class Rack::Lint::HijackWrapper
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  extend ::T::Sig
end

class Rack::MockRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(path, content_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  extend ::T::Sig
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
  extend ::T::Sig
end

class Rack::Reloader
end

class Rack::Request
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  extend ::T::Sig
end

module Rack::Request::Helpers
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  extend ::T::Sig
end

class Rack::Response
  CHUNKED = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  extend ::T::Sig
end

class Rack::Runtime
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&blk); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

class Rack::Session::Abstract::Persisted
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  Unspecified = ::T.let(nil, ::T.untyped)
end

module Rack::Session::Abstract
  extend ::T::Sig
end

class Rack::Session::Dalli
  def destroy_session(env, session_id, options); end

  def find_session(req, sid); end

  def get_session(env, sid); end

  def mutex(); end

  def pool(); end

  def set_session(env, session_id, new_session, options); end
  DEFAULT_DALLI_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Dalli
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

module Rack::Session
  extend ::T::Sig
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  extend ::T::Sig
end

module Rack::Test::Utils
  extend ::T::Sig
end

module Rack::Test
  extend ::T::Sig
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
  INFINITY = ::T.let(nil, ::T.untyped)
  NEGATIVE_INFINITY = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  extend ::T::Sig
end

module Rack
  extend ::T::Sig
end

class Rails::Application
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

module Rails::Application::Bootstrap
  extend ::T::Sig
end

module Rails::Application::Finisher::InterlockHook
  extend ::T::Sig
end

module Rails::Application::Finisher
  extend ::T::Sig
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

module Rails::Command
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
end

module Rails::Command::Actions
  def load_generators(); end

  def load_tasks(); end

  def require_application!(); end

  def require_application_and_environment!(); end

  def require_environment!(); end

  def set_application_directory!(); end
end

module Rails::Command::Actions
  extend ::T::Sig
end

class Rails::Command::Base
  include ::Rails::Command::Actions
  def help(); end
end

class Rails::Command::Base::Error
end

class Rails::Command::Base::Error
end

class Rails::Command::Base
  def self.banner(*_); end

  def self.base_name(); end

  def self.command_name(); end

  def self.default_command_root(); end

  def self.desc(usage=T.unsafe(nil), description=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.engine?(); end

  def self.executable(); end

  def self.hide_command!(); end

  def self.inherited(base); end

  def self.perform(command, args, config); end

  def self.printing_commands(); end

  def self.usage_path(); end
end

module Rails::Command::Behavior::ClassMethods
  extend ::T::Sig
end

module Rails::Command::Behavior
  extend ::T::Sig
end

module Rails::Command
  extend ::T::Sig
end

module Rails::Configuration
  extend ::T::Sig
end

module Rails::Controller::Testing
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rails::Controller::Testing::Integration
  extend ::T::Sig
end

module Rails::Controller::Testing::TemplateAssertions
  RENDER_TEMPLATE_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module Rails::Controller::Testing::TemplateAssertions
  extend ::T::Sig
end

module Rails::Controller::Testing::TestProcess
  extend ::T::Sig
end

module Rails::Controller::Testing
  extend ::T::Sig
end

module Rails::Controller
  extend ::T::Sig
end

module Rails::Dom::Testing::Assertions::DomAssertions
  extend ::T::Sig
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  extend ::T::Sig
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  extend ::T::Sig
end

module Rails::Dom::Testing::Assertions
  extend ::T::Sig
end

module Rails::Dom::Testing
  extend ::T::Sig
end

module Rails::Dom
  extend ::T::Sig
end

module Rails::Generators
  DEFAULT_ALIASES = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil), &block); end

  def after_bundle(&block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def capify!(); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def initialize(*_); end

  def initializer(filename, data=T.unsafe(nil)); end

  def lib(filename, data=T.unsafe(nil)); end

  def rails_command(command, options=T.unsafe(nil)); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil)); end

  def readme(path); end

  def route(routing_code); end

  def vendor(filename, data=T.unsafe(nil)); end
end

class Rails::Generators::Actions::CreateMigration
  def existing_migration(); end

  def migration_dir(); end

  def migration_file_name(); end

  def relative_existing_migration(); end
end

class Rails::Generators::Actions::CreateMigration
end

module Rails::Generators::Actions
  extend ::T::Sig
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end

  def migration_exists?(dirname, file_name); end

  def migration_lookup_at(dirname); end

  def next_migration_number(dirname); end
end

module Rails::Generators::Migration::ClassMethods
  extend ::T::Sig
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class Rails::Generators::NamedBase
  def file_name(); end

  def initialize(args, *options); end

  def js_template(source, destination); end

  def name(); end

  def name=(name); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def controller_file_name(); end

  def controller_name(); end

  def initialize(*args); end
end

module Rails::Generators::ResourceHelpers
  extend ::T::Sig
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::FileUtils::StreamUtils_
end

module Rails::Generators::Testing::Assertions
  extend ::T::Sig
end

module Rails::Generators::Testing::Behaviour
  extend ::T::Sig
end

module Rails::Generators::Testing::SetupAndTeardown
  extend ::T::Sig
end

module Rails::Generators::Testing
  extend ::T::Sig
end

module Rails::Generators
  extend ::T::Sig
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rails::Html
  extend ::T::Sig
end

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  extend ::T::Sig
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

module Rails::Initializable
  extend ::T::Sig
end

module Rails::LineFiltering
  extend ::T::Sig
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

module Rails::Paths
  extend ::T::Sig
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

module Rails::Rack
  extend ::T::Sig
end

class Rails::Railtie
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

module Rails::TestUnit
  extend ::T::Sig
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
  extend ::T::Sig
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rails
  extend ::T::Sig
end

module Rails12factor
  extend ::T::Sig
end

module RailsServeStaticAssets
  VERSION = ::T.let(nil, ::T.untyped)
end

module RailsServeStaticAssets
  extend ::T::Sig
end

module RailsStdoutLogging
  VERSION = ::T.let(nil, ::T.untyped)
end

module RailsStdoutLogging
  extend ::T::Sig
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  extend ::T::Sig
  def self.collapse(backtrace); end
end

module Rake::Cloneable
  extend ::T::Sig
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
  extend ::T::Sig
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
  extend ::T::Sig
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
  extend ::T::Sig
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
  extend ::T::Sig
end

module Rake::PrivateReader
  extend ::T::Sig
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

Rake::RDocTask = RDoc::Task

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

class Rake::TaskLib
  include ::Rake::Cloneable
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Rake::TaskLib
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  extend ::T::Sig
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
  extend ::T::Sig
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
  extend ::T::Sig
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  extend ::T::Sig
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::T::Sig
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

class Random
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

module Random::Formatter
  extend ::T::Sig
end

class Random
  extend ::T::Sig
  extend ::Random::Formatter
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  include ::ActiveSupport::EachTimeWithZone
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def %(_); end

  def entries(); end

  def to_a(); end
end

class Range
  extend ::T::Sig
end

class RangeError
  extend ::T::Sig
end

class Rational
  def to_d(precision); end
end

class Rational
  extend ::T::Sig
end

module RbConfig
  extend ::T::Sig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Readline
  extend ::T::Sig
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(basic_quote_characters); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(basic_word_break_characters); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(completer_quote_characters); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(completer_word_break_characters); end

  def self.completion_append_character(); end

  def self.completion_append_character=(completion_append_character); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(completion_case_fold); end

  def self.completion_proc(); end

  def self.completion_proc=(completion_proc); end

  def self.completion_quote_character(); end

  def self.delete_text(*_); end

  def self.emacs_editing_mode(); end

  def self.emacs_editing_mode?(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(filename_quote_characters); end

  def self.get_screen_size(); end

  def self.input=(input); end

  def self.insert_text(_); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.quoting_detection_proc(); end

  def self.quoting_detection_proc=(quoting_detection_proc); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode(); end

  def self.vi_editing_mode?(); end
end

class Redis
  include ::ActiveSupport::Cache::ConnectionPoolLike
  Boolify = ::T.let(nil, ::T.untyped)
  BoolifySet = ::T.let(nil, ::T.untyped)
  Floatify = ::T.let(nil, ::T.untyped)
  FloatifyPairs = ::T.let(nil, ::T.untyped)
  Hashify = ::T.let(nil, ::T.untyped)
  HashifyClusterNodeInfo = ::T.let(nil, ::T.untyped)
  HashifyClusterNodes = ::T.let(nil, ::T.untyped)
  HashifyClusterSlaves = ::T.let(nil, ::T.untyped)
  HashifyClusterSlots = ::T.let(nil, ::T.untyped)
  HashifyInfo = ::T.let(nil, ::T.untyped)
  HashifyStreamEntries = ::T.let(nil, ::T.untyped)
  HashifyStreamPendingDetails = ::T.let(nil, ::T.untyped)
  HashifyStreamPendings = ::T.let(nil, ::T.untyped)
  HashifyStreams = ::T.let(nil, ::T.untyped)
  Noop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redis::Client
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::CommandLoader
  extend ::T::Sig
end

module Redis::Cluster::KeySlotConverter
  HASH_SLOTS = ::T.let(nil, ::T.untyped)
  XMODEM_CRC16_LOOKUP = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::KeySlotConverter
  extend ::T::Sig
end

class Redis::Cluster::Node
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::NodeKey
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  DELIMITER = ::T.let(nil, ::T.untyped)
  SECURE_SCHEME = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::NodeKey
  extend ::T::Sig
end

module Redis::Cluster::NodeLoader
  extend ::T::Sig
end

class Redis::Cluster::Option
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  SECURE_SCHEME = ::T.let(nil, ::T.untyped)
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Slot
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::SlotLoader
  extend ::T::Sig
end

module Redis::Connection::CommandHelper
  COMMAND_DELIMITER = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::CommandHelper
  extend ::T::Sig
end

class Redis::Connection::Ruby
  ASTERISK = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  DOLLAR = ::T.let(nil, ::T.untyped)
  MINUS = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::SocketMixin
  CRLF = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::SocketMixin
  extend ::T::Sig
end

module Redis::Connection
  extend ::T::Sig
end

class Redis::Distributed
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def [](key); end

  def []=(key, value); end

  def _bpop(cmd, args); end

  def _eval(cmd, args); end

  def add_node(options); end

  def append(key, value); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, options=T.unsafe(nil)); end

  def dbsize(); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*args); end

  def discard(); end

  def dump(key); end

  def echo(value); end

  def ensure_same_node(command, keys); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(key); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(); end

  def flushdb(); end

  def get(key); end

  def getbit(key, offset); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields); end

  def hmset(key, *attrs); end

  def hset(key, field, value); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(node_configs, options=T.unsafe(nil)); end

  def key_tag(key); end

  def keys(glob=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lpop(key); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(hash); end

  def mapped_msetnx(hash); end

  def mget(*keys); end

  def migrate(key, options); end

  def monitor(); end

  def move(key, db); end

  def mset(*args); end

  def msetnx(*args); end

  def multi(); end

  def node_for(key); end

  def node_index_for(key); end

  def nodes(); end

  def on_each_node(command, *args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def punsubscribe(*channels); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, options=T.unsafe(nil)); end

  def ring(); end

  def rpop(key); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def set(key, value, options=T.unsafe(nil)); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def smembers(key); end

  def smove(source, destination, member); end

  def sort(key, options=T.unsafe(nil)); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, options=T.unsafe(nil)); end

  def sscan_each(key, options=T.unsafe(nil), &block); end

  def strlen(key); end

  def subscribe(channel, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*args); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys); end

  def zadd(key, *args); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zincrby(key, increment, member); end

  def zinterstore(destination, keys, options=T.unsafe(nil)); end

  def zrange(key, start, stop, options=T.unsafe(nil)); end

  def zrangebyscore(key, min, max, options=T.unsafe(nil)); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, options=T.unsafe(nil)); end

  def zrevrangebyscore(key, max, min, options=T.unsafe(nil)); end

  def zrevrank(key, member); end

  def zscore(key, member); end

  def zunionstore(destination, keys, options=T.unsafe(nil)); end
end

class Redis::Distributed::CannotDistribute
  def initialize(command); end
end

class Redis::Distributed::CannotDistribute
end

class Redis::Distributed
end

class Redis::Future
  FutureNotReady = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
  def add_node(node); end

  def get_node(key); end

  def get_node_pos(key); end

  def initialize(nodes=T.unsafe(nil), replicas=T.unsafe(nil)); end

  def iter_nodes(key); end

  def nodes(); end

  def remove_node(node); end

  def replicas(); end

  def ring(); end

  def sorted_keys(); end
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
  def self.binary_search(ary, value, &block); end
end

class Regexp
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def match?(*_); end
end

class Regexp
  extend ::T::Sig
  def self.union(*_); end
end

class RegexpError
  extend ::T::Sig
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end

  def state(); end
end

class Ripper::Filter
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  extend ::T::Sig
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  extend ::T::Sig
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::InstructionSequence
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  extend ::T::Sig
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  extend ::T::Sig
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  extend ::T::Sig
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

class RuntimeError
  extend ::T::Sig
end

module SDoc::GitHub
  extend ::T::Sig
end

module SDoc::Helpers
  extend ::T::Sig
end

module SDoc::Templatable
  extend ::T::Sig
end

module SDoc
  extend ::T::Sig
end

module SQLite3
  SQLITE_VERSION = ::T.let(nil, ::T.untyped)
  SQLITE_VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SQLite3::Blob
end

class SQLite3::Blob
end

module SQLite3::Constants::ColumnType
  BLOB = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ColumnType
  extend ::T::Sig
end

module SQLite3::Constants::ErrorCode
  ABORT = ::T.let(nil, ::T.untyped)
  AUTH = ::T.let(nil, ::T.untyped)
  BUSY = ::T.let(nil, ::T.untyped)
  CANTOPEN = ::T.let(nil, ::T.untyped)
  CONSTRAINT = ::T.let(nil, ::T.untyped)
  CORRUPT = ::T.let(nil, ::T.untyped)
  DONE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FULL = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  INTERRUPT = ::T.let(nil, ::T.untyped)
  IOERR = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MISMATCH = ::T.let(nil, ::T.untyped)
  MISUSE = ::T.let(nil, ::T.untyped)
  NOLFS = ::T.let(nil, ::T.untyped)
  NOMEM = ::T.let(nil, ::T.untyped)
  NOTFOUND = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PERM = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  ROW = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  TOOBIG = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ErrorCode
  extend ::T::Sig
end

module SQLite3::Constants::Open
  AUTOPROXY = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETEONCLOSE = ::T.let(nil, ::T.untyped)
  EXCLUSIVE = ::T.let(nil, ::T.untyped)
  FULLMUTEX = ::T.let(nil, ::T.untyped)
  MAIN_DB = ::T.let(nil, ::T.untyped)
  MAIN_JOURNAL = ::T.let(nil, ::T.untyped)
  MASTER_JOURNAL = ::T.let(nil, ::T.untyped)
  MEMORY = ::T.let(nil, ::T.untyped)
  NOMUTEX = ::T.let(nil, ::T.untyped)
  PRIVATECACHE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  READWRITE = ::T.let(nil, ::T.untyped)
  SHAREDCACHE = ::T.let(nil, ::T.untyped)
  SUBJOURNAL = ::T.let(nil, ::T.untyped)
  TEMP_DB = ::T.let(nil, ::T.untyped)
  TEMP_JOURNAL = ::T.let(nil, ::T.untyped)
  TRANSIENT_DB = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  WAL = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
  extend ::T::Sig
end

module SQLite3::Constants::TextRep
  ANY = ::T.let(nil, ::T.untyped)
  DETERMINISTIC = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::TextRep
  extend ::T::Sig
end

module SQLite3::Constants
  extend ::T::Sig
end

class SQLite3::Database
  NULL_TRANSLATOR = ::T.let(nil, ::T.untyped)
end

module SQLite3::Pragmas
  AUTO_VACUUM_MODES = ::T.let(nil, ::T.untyped)
  ENCODINGS = ::T.let(nil, ::T.untyped)
  JOURNAL_MODES = ::T.let(nil, ::T.untyped)
  LOCKING_MODES = ::T.let(nil, ::T.untyped)
  SYNCHRONOUS_MODES = ::T.let(nil, ::T.untyped)
  TEMP_STORE_MODES = ::T.let(nil, ::T.untyped)
  WAL_CHECKPOINTS = ::T.let(nil, ::T.untyped)
end

module SQLite3::Pragmas
  extend ::T::Sig
end

module SQLite3::VersionProxy
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module SQLite3::VersionProxy
  extend ::T::Sig
end

module SQLite3
  extend ::T::Sig
end

module SassC
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::Engine
  OUTPUT_STYLES = ::T.let(nil, ::T.untyped)
end

module SassC::Native
  SassInputStyle = ::T.let(nil, ::T.untyped)
  SassOutputStyle = ::T.let(nil, ::T.untyped)
  SassSeparator = ::T.let(nil, ::T.untyped)
  SassTag = ::T.let(nil, ::T.untyped)
end

module SassC::Native::LibC
  extend ::T::Sig
end

module SassC::Native
  extend ::T::Sig
end

module SassC::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::Rails::Importer
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  GLOB = ::T.let(nil, ::T.untyped)
  PREFIXS = ::T.let(nil, ::T.untyped)
end

module SassC::Rails::SassTemplate::Functions
  extend ::T::Sig
end

module SassC::Rails
  extend ::T::Sig
end

module SassC::Script::Functions
  extend ::T::Sig
end

class SassC::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Number
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

module SassC::Script::ValueConversion
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

module SassC::Script::ValueConversion
  extend ::T::Sig
end

module SassC::Script
  extend ::T::Sig
end

module SassC::Util
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
end

module SassC::Util
  extend ::T::Sig
end

module SassC
  extend ::T::Sig
end

ScanError = StringScanner::Error

class ScriptError
  extend ::T::Sig
end

module SecureRandom
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  extend ::Random::Formatter
  extend ::T::Sig
  def self.bytes(n); end
end

class SecurityError
  extend ::T::Sig
end

class Set
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def filter!(&block); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Set
  extend ::T::Sig
end

module Shellwords
end

module Shellwords
  extend ::T::Sig
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

module Signal
  extend ::T::Sig
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignalException
  extend ::T::Sig
end

class SimpleDelegator
  extend ::T::Sig
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module SingleForwardable
  extend ::T::Sig
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton::SingletonClassMethods
  extend ::T::Sig
end

module Singleton
  extend ::T::Sig
  def self.__init__(klass); end
end

SizedQueue = Thread::SizedQueue

module Skiptrace
  VERSION = ::T.let(nil, ::T.untyped)
end

module Skiptrace
  extend ::T::Sig
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Socket::AncillaryData
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Socket::AncillaryData
  extend ::T::Sig
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  extend ::T::Sig
end

class Socket::Ifaddr
  extend ::T::Sig
end

class Socket::Option
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Socket::Option
  extend ::T::Sig
end

class Socket::UDPSource
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Socket::UDPSource
  extend ::T::Sig
end

class Socket
  extend ::T::Sig
end

class SocketError
  extend ::T::Sig
end

class Sorbet
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.method_added(mod, method, singleton); end

  def self.module_created(mod); end

  def self.module_extended(extended, extender); end

  def self.module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  extend ::T::Sig
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  extend ::T::Sig
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  extend ::T::Sig
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  extend ::T::Sig
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  extend ::T::Sig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private
  extend ::T::Sig
end

class Sorbet
  extend ::T::Sig
end

module SorbetRails::CustomFinderMethods
  extend ::T::Sig
end

module SorbetRails
  extend ::T::Sig
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  extend ::T::Sig
  def self.setup(); end
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

Sprockets::Autoload::Uglifier = Uglifier

module Sprockets::Autoload
  extend ::T::Sig
end

class Sprockets::Base
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Engines
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
end

module Sprockets::Bower
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Bower
  extend ::T::Sig
end

class Sprockets::Cache
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::NullStore
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::ClosureCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  extend ::T::Sig
end

module Sprockets::CoffeeScriptTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptTemplate
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::Compressing
  extend ::T::Sig
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Engines
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::DigestUtils
end

module Sprockets::Configuration
  extend ::T::Sig
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::Dependencies
  extend ::T::Sig
end

module Sprockets::DigestUtils
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

module Sprockets::DigestUtils
  extend ::T::Sig
end

class Sprockets::DirectiveProcessor
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ERBTemplate
  def call(*args); end
end

class Sprockets::ERBTemplate
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  extend ::T::Sig
end

module Sprockets::EcoTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoTemplate
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  extend ::T::Sig
end

module Sprockets::EjsTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsTemplate
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EncodingUtils
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  extend ::T::Sig
end

module Sprockets::Engines
  extend ::T::Sig
end

module Sprockets::HTTPUtils
  extend ::T::Sig
end

Sprockets::Index = Sprockets::CachedEnvironment

module Sprockets::Loader
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
end

module Sprockets::Loader
  extend ::T::Sig
end

module Sprockets::ManifestUtils
  LEGACY_MANIFEST_RE = ::T.let(nil, ::T.untyped)
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::ManifestUtils
  extend ::T::Sig
end

module Sprockets::Mime
  include ::Sprockets::Utils
end

module Sprockets::Mime
  extend ::T::Sig
end

module Sprockets::PathDependencyUtils
  extend ::T::Sig
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::PathDigestUtils
  extend ::T::Sig
end

module Sprockets::PathUtils
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::PathUtils
  extend ::T::Sig
end

module Sprockets::Paths
  include ::Sprockets::Utils
end

module Sprockets::Paths
  extend ::T::Sig
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
end

module Sprockets::Processing
  extend ::T::Sig
end

module Sprockets::ProcessorUtils
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

module Sprockets::ProcessorUtils
  extend ::T::Sig
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Context
  extend ::T::Sig
end

module Sprockets::Rails::Helper
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  extend ::T::Sig
end

module Sprockets::Rails::HelperAssetResolvers
  extend ::T::Sig
end

module Sprockets::Rails::RouteWrapper
  extend ::T::Sig
end

module Sprockets::Rails::Utils
  extend ::T::Sig
end

module Sprockets::Rails
  extend ::T::Sig
end

class Sprockets::Railtie
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
end

module Sprockets::Resolve
  extend ::T::Sig
end

class Sprockets::SassCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

Sprockets::SassFunctions = Sprockets::SassProcessor::Functions

module Sprockets::SassProcessor::Functions
  extend ::T::Sig
end

class Sprockets::SassTemplate
end

class Sprockets::SassTemplate
  def self.call(*args); end
end

class Sprockets::ScssTemplate
end

class Sprockets::ScssTemplate
  def self.call(*args); end
end

module Sprockets::Server
  extend ::T::Sig
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
end

module Sprockets::Transformers
  extend ::T::Sig
end

module Sprockets::URIUtils
  extend ::T::Sig
end

class Sprockets::UglifierCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Utils
  UNBOUND_METHODS_BIND_TO_ANY_OBJECT = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Sprockets::Utils
  extend ::T::Sig
end

class Sprockets::YUICompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Engines
  extend ::Sprockets::Mime
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::DigestUtils
  extend ::T::Sig
end

class StandardError
  extend ::T::Sig
end

class StopIteration
  def result(); end
end

class StopIteration
  extend ::T::Sig
end

class String
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def +@(); end

  def -@(); end

  def []=(*_); end

  def casecmp?(_); end

  def delete_prefix(_); end

  def delete_prefix!(_); end

  def delete_suffix(_); end

  def delete_suffix!(_); end

  def each_grapheme_cluster(); end

  def encode(*_); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def match?(*_); end

  def parse_csv(**options); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_d(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end

  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class String
  extend ::T::Sig
end

class StringIO
  def length(); end

  def truncate(_); end

end

class StringIO
  extend ::T::Sig
end

class StringScanner
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner::Error
  extend ::T::Sig
end

class StringScanner
  extend ::T::Sig
  def self.must_C_version(); end
end

class Struct
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Struct
  extend ::T::Sig
end

class Symbol
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def casecmp?(_); end

  def match?(*_); end

  def next(); end

end

class Symbol
  extend ::T::Sig
end

class SyntaxError
  extend ::T::Sig
end

class SystemCallError
  def errno(); end
end

class SystemCallError
  extend ::T::Sig
end

class SystemExit
  def status(); end

  def success?(); end
end

class SystemExit
  extend ::T::Sig
end

class SystemStackError
  extend ::T::Sig
end

class TCPServer
  extend ::T::Sig
end

class TCPSocket
  extend ::T::Sig
end

class TSort::Cyclic
  extend ::T::Sig
end

module TSort
  extend ::T::Sig
end

module TZInfo::CountryIndexDefinition::ClassMethods
  extend ::T::Sig
end

module TZInfo::CountryIndexDefinition
  extend ::T::Sig
end

module TZInfo::OffsetRationals
  extend ::T::Sig
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

module TZInfo::RubyCoreSupport
  extend ::T::Sig
end

class TZInfo::RubyDataSource
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

module TZInfo::TimezoneDefinition::ClassMethods
  extend ::T::Sig
end

module TZInfo::TimezoneDefinition
  extend ::T::Sig
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
  extend ::T::Sig
end

module TZInfo::TimezoneIndexDefinition
  extend ::T::Sig
end

class TZInfo::ZoneinfoDataSource
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

module TZInfo
  extend ::T::Sig
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thor
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

module Thor::Actions
  extend ::T::Sig
  def self.included(base); end
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  NUMERIC = ::T.let(nil, ::T.untyped)
end

module Thor::Base
  extend ::T::Sig
end

class Thor::Command
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

module Thor::CoreExt
  extend ::T::Sig
end

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Group
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

Thor::HiddenTask = Thor::HiddenCommand

module Thor::Invocation
  extend ::T::Sig
end

module Thor::LineEditor
  extend ::T::Sig
end

class Thor::Option
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  extend ::T::Sig
  def self.included(base); end

  def self.rake_classes(); end
end

module Thor::Sandbox
  extend ::T::Sig
end

module Thor::Shell
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Thor::Shell
  extend ::T::Sig
end

Thor::Task = Thor::Command

Thor::UndefinedTaskError = Thor::UndefinedCommandError

module Thor::Util
  extend ::T::Sig
end

class Thread
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def abort_on_exception(); end

  def abort_on_exception=(abort_on_exception); end

  def add_trace_func(_); end

  def backtrace(*_); end

  def backtrace_locations(*_); end

  def exit(); end

  def fetch(*_); end

  def group(); end

  def initialize(*_); end

  def join(*_); end

  def key?(_); end

  def keys(); end

  def name(); end

  def name=(name); end

  def pending_interrupt?(*_); end

  def priority(); end

  def priority=(priority); end

  def report_on_exception(); end

  def report_on_exception=(report_on_exception); end

  def run(); end

  def safe_level(); end

  def status(); end

  def stop?(); end

  def terminate(); end

  def thread_variable?(_); end

  def thread_variable_get(_); end

  def thread_variable_set(_, _1); end

  def thread_variables(); end

  def value(); end

  def wakeup(); end
end

class Thread::Backtrace
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Thread::Backtrace::Location
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Thread::Backtrace::Location
  extend ::T::Sig
end

class Thread::Backtrace
  extend ::T::Sig
end

class Thread::ConditionVariable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def broadcast(); end

  def marshal_dump(); end

  def signal(); end

  def wait(*_); end
end

class Thread::ConditionVariable
  extend ::T::Sig
end

class Thread::Mutex
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def lock(); end

  def locked?(); end

  def owned?(); end

  def synchronize(); end

  def try_lock(); end

  def unlock(); end
end

class Thread::Mutex
  extend ::T::Sig
end

class Thread::Queue
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(_); end

  def clear(); end

  def close(); end

  def closed?(); end

  def deq(*_); end

  def empty?(); end

  def enq(_); end

  def length(); end

  def marshal_dump(); end

  def num_waiting(); end

  def pop(*_); end

  def push(_); end

  def shift(*_); end

  def size(); end
end

class Thread::Queue
  extend ::T::Sig
end

class Thread::SizedQueue
  def <<(*_); end

  def enq(*_); end

  def initialize(_); end

  def max(); end

  def max=(max); end

  def push(*_); end
end

class Thread::SizedQueue
  extend ::T::Sig
end

class Thread
  extend ::T::Sig
  def self.abort_on_exception(); end

  def self.abort_on_exception=(abort_on_exception); end

  def self.exclusive(&block); end

  def self.exit(); end

  def self.fork(*_); end

  def self.handle_interrupt(_); end

  def self.kill(_); end

  def self.list(); end

  def self.pass(); end

  def self.pending_interrupt?(*_); end

  def self.report_on_exception(); end

  def self.report_on_exception=(report_on_exception); end

  def self.start(*_); end

  def self.stop(); end
end

class ThreadError
  extend ::T::Sig
end

class ThreadGroup
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def add(_); end

  def enclose(); end

  def enclosed?(); end

  def list(); end
  Default = ::T.let(nil, ::T.untyped)
end

class ThreadGroup
  extend ::T::Sig
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
  extend ::T::Sig
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
  extend ::T::Sig
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
  extend ::T::Sig
end

module ThreadSafe::Util
  extend ::T::Sig
end

module ThreadSafe
  extend ::T::Sig
end

module Threadsafe
  extend ::T::Sig
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

module Tilt::CompiledTemplates
  extend ::T::Sig
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::ErubiTemplate
  def precompiled_template(locals); end
end

class Tilt::ErubiTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SassTemplate
  def allows_script?(); end
end

Tilt::SassTemplate::Sass = SassC

class Tilt::SassTemplate
end

class Tilt::ScssTemplate
end

class Tilt::ScssTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

module Tilt
  extend ::T::Sig
end

class Time
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Time
  extend ::T::Sig
end

class Timeout::Error
  extend ::T::Sig
end

module Timeout
  extend ::T::Sig
end

module ToyApp
end

class ToyApp::Application
end

class ToyApp::Application
end

module ToyApp
  extend ::T::Sig
end

class TracePoint
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  extend ::T::Sig
end

class TrueClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class TrueClass
  extend ::T::Sig
end

module Turbolinks
  VERSION = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Assertions
  TURBOLINKS_VISIT = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Assertions
  extend ::T::Sig
end

module Turbolinks::Controller
  extend ::T::Sig
end

module Turbolinks::Redirection
  extend ::T::Sig
end

module Turbolinks::Source
  VERSION = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Source
  extend ::T::Sig
end

module Turbolinks
  extend ::T::Sig
end

class TypeError
  extend ::T::Sig
end

class UDPSocket
  extend ::T::Sig
end

class UNIXServer
  extend ::T::Sig
end

class UNIXSocket
  extend ::T::Sig
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::BadURIError
  extend ::T::Sig
end

class URI::Error
  extend ::T::Sig
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module URI::Escape
  extend ::T::Sig
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  extend ::T::Sig
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::Generic
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
end

class URI::Generic
  extend ::T::Sig
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class URI::HTTP
  def request_uri(); end
end

class URI::HTTP
  extend ::T::Sig
end

class URI::HTTPS
  extend ::T::Sig
end

class URI::InvalidComponentError
  extend ::T::Sig
end

class URI::InvalidURIError
  extend ::T::Sig
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::LDAP
  extend ::T::Sig
end

class URI::LDAPS
  extend ::T::Sig
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

class URI::MailTo
  extend ::T::Sig
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC2396_Parser
  extend ::T::Sig
end

module URI::RFC2396_REGEXP::PATTERN
  extend ::T::Sig
end

module URI::RFC2396_REGEXP
  extend ::T::Sig
end

class URI::RFC3986_Parser
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class URI::RFC3986_Parser
  extend ::T::Sig
end

module URI::Util
  extend ::T::Sig
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::T::Sig
  extend ::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end
end

class Uglifier
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ES5FallbackPath = ::T.let(nil, ::T.untyped)
  EXTRA_OPTIONS = ::T.let(nil, ::T.untyped)
  HarmonySourcePath = ::T.let(nil, ::T.untyped)
  MANGLE_PROPERTIES_DEFAULTS = ::T.let(nil, ::T.untyped)
  SOURCE_MAP_DEFAULTS = ::T.let(nil, ::T.untyped)
  SourceMapPath = ::T.let(nil, ::T.untyped)
  SourcePath = ::T.let(nil, ::T.untyped)
  SplitFallbackPath = ::T.let(nil, ::T.untyped)
  UglifyJSWrapperPath = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class UnboundMethod
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def clone(); end

  def original_name(); end
end

class UnboundMethod
  extend ::T::Sig
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

class UncaughtThrowError
  extend ::T::Sig
end

module UnicodeNormalize
end

module UnicodeNormalize
  extend ::T::Sig
end

class User
  include ::User::GeneratedAssociationMethods
  def after_add_for_microposts(); end

  def after_add_for_microposts=(val); end

  def after_add_for_microposts?(); end

  def after_remove_for_microposts(); end

  def after_remove_for_microposts=(val); end

  def after_remove_for_microposts?(); end

  def autosave_associated_records_for_microposts(*args); end

  def before_add_for_microposts(); end

  def before_add_for_microposts=(val); end

  def before_add_for_microposts?(); end

  def before_remove_for_microposts(); end

  def before_remove_for_microposts=(val); end

  def before_remove_for_microposts?(); end

  def validate_associated_records_for_microposts(*args); end
end

module User::GeneratedAssociationMethods
  def micropost_ids(); end

  def micropost_ids=(ids); end

  def microposts(); end

  def microposts=(value); end
end

module User::GeneratedAssociationMethods
  extend ::T::Sig
end

class User
  def self.after_add_for_microposts(); end

  def self.after_add_for_microposts=(val); end

  def self.after_add_for_microposts?(); end

  def self.after_remove_for_microposts(); end

  def self.after_remove_for_microposts=(val); end

  def self.after_remove_for_microposts?(); end

  def self.before_add_for_microposts(); end

  def self.before_add_for_microposts=(val); end

  def self.before_add_for_microposts?(); end

  def self.before_remove_for_microposts(); end

  def self.before_remove_for_microposts=(val); end

  def self.before_remove_for_microposts?(); end
end

class UsersController
  def create(); end

  def destroy(); end

  def edit(); end

  def index(); end

  def new(); end

  def show(); end

  def update(); end
end

class UsersController
end

module UsersHelper
  extend ::T::Sig
end

Visitor = Psych::Visitors::Visitor

class WEBrick::HTTPServlet::AbstractServlet
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class WEBrick::HTTPServlet::AbstractServlet
  extend ::T::Sig
end

module Warning
  def warn(_); end
end

module Warning
  extend ::T::Sig
  extend ::Warning
end

class WebConsole::Context
  def extract(input=T.unsafe(nil)); end

  def initialize(binding); end
  GLOBAL_OBJECTS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Context
end

class WebConsole::DoubleRenderError
end

class WebConsole::DoubleRenderError
end

class WebConsole::Error
end

class WebConsole::Error
end

class WebConsole::Evaluator
  def cleaner(); end

  def eval(input); end

  def initialize(binding=T.unsafe(nil)); end
end

class WebConsole::Evaluator
  def self.cleaner(); end
end

class WebConsole::ExceptionMapper
  def [](index); end

  def first(); end

  def initialize(exception); end
end

class WebConsole::ExceptionMapper
end

class WebConsole::Injector
  def initialize(body, headers); end

  def inject(content); end
end

class WebConsole::Injector
end

class WebConsole::Middleware
  TEMPLATES_PATH = ::T.let(nil, ::T.untyped)
end

class WebConsole::Session
  def context(objpath); end

  def eval(input); end

  def id(); end

  def initialize(bindings); end

  def inmemory_storage(); end

  def switch_binding_to(index); end
end

class WebConsole::Session
  def self.find(id); end

  def self.from(storage); end

  def self.inmemory_storage(); end
end

class WebConsole::Template
  def initialize(env, session); end

  def render(template); end

  def template_paths(); end

  def template_paths=(obj); end
end

class WebConsole::Template
  def self.template_paths(); end

  def self.template_paths=(obj); end
end

class WebConsole::View
  def only_on_error_page(*args); end

  def only_on_regular_page(*args); end

  def render(*_); end

  def render_inlined_string(template); end

  def render_javascript(template); end
end

class WebConsole::View
end

class WebConsole::WhinyRequest
  def from_whitelisted_ip?(); end
end

class WebConsole::WhinyRequest
end

class WebConsole::Whitelist
  ALWAYS_WHITELISTED_NETWORKS = ::T.let(nil, ::T.untyped)
end

module WebConsole
  extend ::T::Sig
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

class ZeroDivisionError
  extend ::T::Sig
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  extend ::T::Sig
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
